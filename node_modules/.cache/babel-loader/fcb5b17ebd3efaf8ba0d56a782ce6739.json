{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { format, isEOL } from './format';\nimport { parseTree, findNodeAtLocation } from './parser';\nexport function removeProperty(text, path, options) {\n  return setProperty(text, path, void 0, options);\n}\nexport function setProperty(text, originalPath, value, options) {\n  var _a;\n\n  var path = originalPath.slice();\n  var errors = [];\n  var root = parseTree(text, errors);\n  var parent = void 0;\n  var lastSegment = void 0;\n\n  while (path.length > 0) {\n    lastSegment = path.pop();\n    parent = findNodeAtLocation(root, path);\n\n    if (parent === void 0 && value !== void 0) {\n      if (typeof lastSegment === 'string') {\n        value = (_a = {}, _a[lastSegment] = value, _a);\n      } else {\n        value = [value];\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (!parent) {\n    // empty document\n    if (value === void 0) {\n      // delete\n      throw new Error('Can not delete in empty document');\n    }\n\n    return withFormatting(text, {\n      offset: root ? root.offset : 0,\n      length: root ? root.length : 0,\n      content: JSON.stringify(value)\n    }, options);\n  } else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n    var existing = findNodeAtLocation(parent, [lastSegment]);\n\n    if (existing !== void 0) {\n      if (value === void 0) {\n        // delete\n        if (!existing.parent) {\n          throw new Error('Malformed AST');\n        }\n\n        var propertyIndex = parent.children.indexOf(existing.parent);\n        var removeBegin = void 0;\n        var removeEnd = existing.parent.offset + existing.parent.length;\n\n        if (propertyIndex > 0) {\n          // remove the comma of the previous node\n          var previous = parent.children[propertyIndex - 1];\n          removeBegin = previous.offset + previous.length;\n        } else {\n          removeBegin = parent.offset + 1;\n\n          if (parent.children.length > 1) {\n            // remove the comma of the next node\n            var next = parent.children[1];\n            removeEnd = next.offset;\n          }\n        }\n\n        return withFormatting(text, {\n          offset: removeBegin,\n          length: removeEnd - removeBegin,\n          content: ''\n        }, options);\n      } else {\n        // set value of existing property\n        return withFormatting(text, {\n          offset: existing.offset,\n          length: existing.length,\n          content: JSON.stringify(value)\n        }, options);\n      }\n    } else {\n      if (value === void 0) {\n        // delete\n        return []; // property does not exist, nothing to do\n      }\n\n      var newProperty = \"\".concat(JSON.stringify(lastSegment), \": \").concat(JSON.stringify(value));\n      var index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map(function (p) {\n        return p.children[0].value;\n      })) : parent.children.length;\n      var edit = void 0;\n\n      if (index > 0) {\n        var previous = parent.children[index - 1];\n        edit = {\n          offset: previous.offset + previous.length,\n          length: 0,\n          content: ',' + newProperty\n        };\n      } else if (parent.children.length === 0) {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: newProperty\n        };\n      } else {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: newProperty + ','\n        };\n      }\n\n      return withFormatting(text, edit, options);\n    }\n  } else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n    var insertIndex = lastSegment;\n\n    if (insertIndex === -1) {\n      // Insert\n      var newProperty = \"\".concat(JSON.stringify(value));\n      var edit = void 0;\n\n      if (parent.children.length === 0) {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: newProperty\n        };\n      } else {\n        var previous = parent.children[parent.children.length - 1];\n        edit = {\n          offset: previous.offset + previous.length,\n          length: 0,\n          content: ',' + newProperty\n        };\n      }\n\n      return withFormatting(text, edit, options);\n    } else if (value === void 0 && parent.children.length >= 0) {\n      // Removal\n      var removalIndex = lastSegment;\n      var toRemove = parent.children[removalIndex];\n      var edit = void 0;\n\n      if (parent.children.length === 1) {\n        // only item\n        edit = {\n          offset: parent.offset + 1,\n          length: parent.length - 2,\n          content: ''\n        };\n      } else if (parent.children.length - 1 === removalIndex) {\n        // last item\n        var previous = parent.children[removalIndex - 1];\n        var offset = previous.offset + previous.length;\n        var parentEndOffset = parent.offset + parent.length;\n        edit = {\n          offset: offset,\n          length: parentEndOffset - 2 - offset,\n          content: ''\n        };\n      } else {\n        edit = {\n          offset: toRemove.offset,\n          length: parent.children[removalIndex + 1].offset - toRemove.offset,\n          content: ''\n        };\n      }\n\n      return withFormatting(text, edit, options);\n    } else if (value !== void 0) {\n      var edit = void 0;\n      var newProperty = \"\".concat(JSON.stringify(value));\n\n      if (!options.isArrayInsertion && parent.children.length > lastSegment) {\n        var toModify = parent.children[lastSegment];\n        edit = {\n          offset: toModify.offset,\n          length: toModify.length,\n          content: newProperty\n        };\n      } else if (parent.children.length === 0 || lastSegment === 0) {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: parent.children.length === 0 ? newProperty : newProperty + ','\n        };\n      } else {\n        var index = lastSegment > parent.children.length ? parent.children.length : lastSegment;\n        var previous = parent.children[index - 1];\n        edit = {\n          offset: previous.offset + previous.length,\n          length: 0,\n          content: ',' + newProperty\n        };\n      }\n\n      return withFormatting(text, edit, options);\n    } else {\n      throw new Error(\"Can not \".concat(value === void 0 ? 'remove' : options.isArrayInsertion ? 'insert' : 'modify', \" Array index \").concat(insertIndex, \" as length is not sufficient\"));\n    }\n  } else {\n    throw new Error(\"Can not add \".concat(typeof lastSegment !== 'number' ? 'index' : 'property', \" to parent of type \").concat(parent.type));\n  }\n}\n\nfunction withFormatting(text, edit, options) {\n  if (!options.formattingOptions) {\n    return [edit];\n  } // apply the edit\n\n\n  var newText = applyEdit(text, edit); // format the new text\n\n  var begin = edit.offset;\n  var end = edit.offset + edit.content.length;\n\n  if (edit.length === 0 || edit.content.length === 0) {\n    // insert or remove\n    while (begin > 0 && !isEOL(newText, begin - 1)) {\n      begin--;\n    }\n\n    while (end < newText.length && !isEOL(newText, end)) {\n      end++;\n    }\n  }\n\n  var edits = format(newText, {\n    offset: begin,\n    length: end - begin\n  }, __assign(__assign({}, options.formattingOptions), {\n    keepLines: false\n  })); // apply the formatting edits and track the begin and end offsets of the changes\n\n  for (var i = edits.length - 1; i >= 0; i--) {\n    var edit_1 = edits[i];\n    newText = applyEdit(newText, edit_1);\n    begin = Math.min(begin, edit_1.offset);\n    end = Math.max(end, edit_1.offset + edit_1.length);\n    end += edit_1.content.length - edit_1.length;\n  } // create a single edit with all changes\n\n\n  var editLength = text.length - (newText.length - end) - begin;\n  return [{\n    offset: begin,\n    length: editLength,\n    content: newText.substring(begin, end)\n  }];\n}\n\nexport function applyEdit(text, edit) {\n  return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n}\nexport function isWS(text, offset) {\n  return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n}","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","format","isEOL","parseTree","findNodeAtLocation","removeProperty","text","path","options","setProperty","originalPath","value","_a","slice","errors","root","parent","lastSegment","pop","Error","withFormatting","offset","content","JSON","stringify","type","Array","isArray","children","existing","propertyIndex","indexOf","removeBegin","removeEnd","previous","next","newProperty","concat","index","getInsertionIndex","map","edit","insertIndex","removalIndex","toRemove","parentEndOffset","isArrayInsertion","toModify","formattingOptions","newText","applyEdit","begin","end","edits","keepLines","edit_1","Math","min","max","editLength","substring","isWS","charAt"],"sources":["/Users/braxtoncoats/Github/bcd/node_modules/jsonc-parser/lib/esm/impl/edit.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { format, isEOL } from './format';\nimport { parseTree, findNodeAtLocation } from './parser';\nexport function removeProperty(text, path, options) {\n    return setProperty(text, path, void 0, options);\n}\nexport function setProperty(text, originalPath, value, options) {\n    var _a;\n    var path = originalPath.slice();\n    var errors = [];\n    var root = parseTree(text, errors);\n    var parent = void 0;\n    var lastSegment = void 0;\n    while (path.length > 0) {\n        lastSegment = path.pop();\n        parent = findNodeAtLocation(root, path);\n        if (parent === void 0 && value !== void 0) {\n            if (typeof lastSegment === 'string') {\n                value = (_a = {}, _a[lastSegment] = value, _a);\n            }\n            else {\n                value = [value];\n            }\n        }\n        else {\n            break;\n        }\n    }\n    if (!parent) {\n        // empty document\n        if (value === void 0) { // delete\n            throw new Error('Can not delete in empty document');\n        }\n        return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, options);\n    }\n    else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n        var existing = findNodeAtLocation(parent, [lastSegment]);\n        if (existing !== void 0) {\n            if (value === void 0) { // delete\n                if (!existing.parent) {\n                    throw new Error('Malformed AST');\n                }\n                var propertyIndex = parent.children.indexOf(existing.parent);\n                var removeBegin = void 0;\n                var removeEnd = existing.parent.offset + existing.parent.length;\n                if (propertyIndex > 0) {\n                    // remove the comma of the previous node\n                    var previous = parent.children[propertyIndex - 1];\n                    removeBegin = previous.offset + previous.length;\n                }\n                else {\n                    removeBegin = parent.offset + 1;\n                    if (parent.children.length > 1) {\n                        // remove the comma of the next node\n                        var next = parent.children[1];\n                        removeEnd = next.offset;\n                    }\n                }\n                return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, options);\n            }\n            else {\n                // set value of existing property\n                return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, options);\n            }\n        }\n        else {\n            if (value === void 0) { // delete\n                return []; // property does not exist, nothing to do\n            }\n            var newProperty = \"\".concat(JSON.stringify(lastSegment), \": \").concat(JSON.stringify(value));\n            var index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map(function (p) { return p.children[0].value; })) : parent.children.length;\n            var edit = void 0;\n            if (index > 0) {\n                var previous = parent.children[index - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            else if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };\n            }\n            return withFormatting(text, edit, options);\n        }\n    }\n    else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n        var insertIndex = lastSegment;\n        if (insertIndex === -1) {\n            // Insert\n            var newProperty = \"\".concat(JSON.stringify(value));\n            var edit = void 0;\n            if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                var previous = parent.children[parent.children.length - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else if (value === void 0 && parent.children.length >= 0) {\n            // Removal\n            var removalIndex = lastSegment;\n            var toRemove = parent.children[removalIndex];\n            var edit = void 0;\n            if (parent.children.length === 1) {\n                // only item\n                edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };\n            }\n            else if (parent.children.length - 1 === removalIndex) {\n                // last item\n                var previous = parent.children[removalIndex - 1];\n                var offset = previous.offset + previous.length;\n                var parentEndOffset = parent.offset + parent.length;\n                edit = { offset: offset, length: parentEndOffset - 2 - offset, content: '' };\n            }\n            else {\n                edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else if (value !== void 0) {\n            var edit = void 0;\n            var newProperty = \"\".concat(JSON.stringify(value));\n            if (!options.isArrayInsertion && parent.children.length > lastSegment) {\n                var toModify = parent.children[lastSegment];\n                edit = { offset: toModify.offset, length: toModify.length, content: newProperty };\n            }\n            else if (parent.children.length === 0 || lastSegment === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: parent.children.length === 0 ? newProperty : newProperty + ',' };\n            }\n            else {\n                var index = lastSegment > parent.children.length ? parent.children.length : lastSegment;\n                var previous = parent.children[index - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else {\n            throw new Error(\"Can not \".concat(value === void 0 ? 'remove' : (options.isArrayInsertion ? 'insert' : 'modify'), \" Array index \").concat(insertIndex, \" as length is not sufficient\"));\n        }\n    }\n    else {\n        throw new Error(\"Can not add \".concat(typeof lastSegment !== 'number' ? 'index' : 'property', \" to parent of type \").concat(parent.type));\n    }\n}\nfunction withFormatting(text, edit, options) {\n    if (!options.formattingOptions) {\n        return [edit];\n    }\n    // apply the edit\n    var newText = applyEdit(text, edit);\n    // format the new text\n    var begin = edit.offset;\n    var end = edit.offset + edit.content.length;\n    if (edit.length === 0 || edit.content.length === 0) { // insert or remove\n        while (begin > 0 && !isEOL(newText, begin - 1)) {\n            begin--;\n        }\n        while (end < newText.length && !isEOL(newText, end)) {\n            end++;\n        }\n    }\n    var edits = format(newText, { offset: begin, length: end - begin }, __assign(__assign({}, options.formattingOptions), { keepLines: false }));\n    // apply the formatting edits and track the begin and end offsets of the changes\n    for (var i = edits.length - 1; i >= 0; i--) {\n        var edit_1 = edits[i];\n        newText = applyEdit(newText, edit_1);\n        begin = Math.min(begin, edit_1.offset);\n        end = Math.max(end, edit_1.offset + edit_1.length);\n        end += edit_1.content.length - edit_1.length;\n    }\n    // create a single edit with all changes\n    var editLength = text.length - (newText.length - end) - begin;\n    return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];\n}\nexport function applyEdit(text, edit) {\n    return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n}\nexport function isWS(text, offset) {\n    return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}