{"ast":null,"code":"/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nconst defaultFormatting = {\n  prefix: '',\n  commentStyle: 'long',\n  indentation: '',\n  separator: ' =',\n  suffix: ';'\n};\n/**\n * Creates a function that can be used to format a property. This can be useful\n * to use as the function on `dictionary.allTokens.map`. The formatting\n * is configurable either by supplying a `format` option or a `formatting` object\n * which uses: prefix, indentation, separator, suffix, and commentStyle.\n * @memberof module:formatHelpers\n * @example\n * ```javascript\n * StyleDictionary.registerFormat({\n *   name: 'myCustomFormat',\n *   formatter: function({ dictionary, options }) {\n *     const { outputReferences } = options;\n *     const formatProperty = createPropertyFormatter({\n *       outputReferences,\n *       dictionary,\n *       format: 'css'\n *     });\n *     return dictionary.allTokens.map(formatProperty).join('\\n');\n *   }\n * });\n * ```\n * @param {Object} options\n * @param {Boolean} options.outputReferences - Whether or not to output references. You will want to pass this from the `options` object sent to the formatter function.\n * @param {Boolean} options.outputReferenceFallbacks - Whether or not to output css variable fallback values when using output references. You will want to pass this from the `options` object sent to the formatter function.\n * @param {Dictionary} options.dictionary - The dictionary object sent to the formatter function\n * @param {String} options.format - Available formats are: 'css', 'sass', 'less', and 'stylus'. If you want to customize the format and can't use one of those predefined formats, use the `formatting` option\n * @param {Object} options.formatting - Custom formatting properties that define parts of a declaration line in code. The configurable strings are: prefix, indentation, separator, suffix, and commentStyle. Those are used to generate a line like this: `${indentation}${prefix}${prop.name}${separator} ${prop.value}${suffix}`\n * @param {Boolean} options.themeable [false] - Whether tokens should default to being themeable.\n * @returns {Function}\n */\n\nfunction createPropertyFormatter(_ref) {\n  let {\n    outputReferences = false,\n    outputReferenceFallbacks = false,\n    dictionary,\n    format,\n    formatting = {},\n    themeable = false\n  } = _ref;\n  let {\n    prefix,\n    commentStyle,\n    indentation,\n    separator,\n    suffix\n  } = Object.assign({}, defaultFormatting, formatting);\n\n  switch (format) {\n    case 'css':\n      prefix = '--';\n      indentation = '  ';\n      separator = ':';\n      break;\n\n    case 'sass':\n      prefix = '$';\n      commentStyle = 'short';\n      indentation = '';\n      separator = ':';\n      break;\n\n    case 'less':\n      prefix = '@';\n      commentStyle = 'short';\n      indentation = '';\n      separator = ':';\n      break;\n\n    case 'stylus':\n      prefix = '$';\n      commentStyle = 'short';\n      indentation = '';\n      separator = '=';\n      break;\n  }\n\n  return function (prop) {\n    let to_ret_prop = `${indentation}${prefix}${prop.name}${separator} `;\n    let value = prop.value;\n    /**\n     * A single value can have multiple references either by interpolation:\n     * \"value\": \"{size.border.width.value} solid {color.border.primary.value}\"\n     * or if the value is an object:\n     * \"value\": {\n     *    \"size\": \"{size.border.width.value}\",\n     *    \"style\": \"solid\",\n     *    \"color\": \"{color.border.primary.value\"}\n     * }\n     * This will see if there are references and if there are, replace\n     * the resolved value with the reference's name.\n     */\n\n    if (outputReferences && dictionary.usesReference(prop.original.value)) {\n      // Formats that use this function expect `value` to be a string\n      // or else you will get '[object Object]' in the output\n      if (typeof value === 'string') {\n        const refs = dictionary.getReferences(prop.original.value);\n        refs.forEach(ref => {\n          // value should be a string that contains the resolved reference\n          // because Style Dictionary resolved this in the resolution step.\n          // Here we are undoing that by replacing the value with\n          // the reference's name\n          if (ref.value && ref.name) {\n            value = value.replace(ref.value, function () {\n              if (format === 'css') {\n                if (outputReferenceFallbacks) {\n                  return `var(${prefix}${ref.name}, ${ref.value})`;\n                } else {\n                  return `var(${prefix}${ref.name})`;\n                }\n              } else {\n                return `${prefix}${ref.name}`;\n              }\n            });\n          }\n        });\n      }\n    }\n\n    to_ret_prop += prop.attributes.category === 'asset' ? `\"${value}\"` : value;\n    const themeable_prop = typeof prop.themeable === 'boolean' ? prop.themeable : themeable;\n\n    if (format === 'sass' && themeable_prop) {\n      to_ret_prop += ' !default';\n    }\n\n    to_ret_prop += suffix;\n\n    if (prop.comment && commentStyle !== 'none') {\n      if (commentStyle === 'short') {\n        to_ret_prop = to_ret_prop.concat(` // ${prop.comment}`);\n      } else {\n        to_ret_prop = to_ret_prop.concat(` /* ${prop.comment} */`);\n      }\n    }\n\n    return to_ret_prop;\n  };\n}\n\nmodule.exports = createPropertyFormatter;","map":{"version":3,"names":["defaultFormatting","prefix","commentStyle","indentation","separator","suffix","createPropertyFormatter","outputReferences","outputReferenceFallbacks","dictionary","format","formatting","themeable","Object","assign","prop","to_ret_prop","name","value","usesReference","original","refs","getReferences","forEach","ref","replace","attributes","category","themeable_prop","comment","concat","module","exports"],"sources":["/Users/braxtoncoats/Github/bcd/node_modules/style-dictionary/lib/common/formatHelpers/createPropertyFormatter.js"],"sourcesContent":["/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\nconst defaultFormatting = {\n  prefix: '',\n  commentStyle: 'long',\n  indentation: '',\n  separator: ' =',\n  suffix: ';'\n}\n\n/**\n * Creates a function that can be used to format a property. This can be useful\n * to use as the function on `dictionary.allTokens.map`. The formatting\n * is configurable either by supplying a `format` option or a `formatting` object\n * which uses: prefix, indentation, separator, suffix, and commentStyle.\n * @memberof module:formatHelpers\n * @example\n * ```javascript\n * StyleDictionary.registerFormat({\n *   name: 'myCustomFormat',\n *   formatter: function({ dictionary, options }) {\n *     const { outputReferences } = options;\n *     const formatProperty = createPropertyFormatter({\n *       outputReferences,\n *       dictionary,\n *       format: 'css'\n *     });\n *     return dictionary.allTokens.map(formatProperty).join('\\n');\n *   }\n * });\n * ```\n * @param {Object} options\n * @param {Boolean} options.outputReferences - Whether or not to output references. You will want to pass this from the `options` object sent to the formatter function.\n * @param {Boolean} options.outputReferenceFallbacks - Whether or not to output css variable fallback values when using output references. You will want to pass this from the `options` object sent to the formatter function.\n * @param {Dictionary} options.dictionary - The dictionary object sent to the formatter function\n * @param {String} options.format - Available formats are: 'css', 'sass', 'less', and 'stylus'. If you want to customize the format and can't use one of those predefined formats, use the `formatting` option\n * @param {Object} options.formatting - Custom formatting properties that define parts of a declaration line in code. The configurable strings are: prefix, indentation, separator, suffix, and commentStyle. Those are used to generate a line like this: `${indentation}${prefix}${prop.name}${separator} ${prop.value}${suffix}`\n * @param {Boolean} options.themeable [false] - Whether tokens should default to being themeable.\n * @returns {Function}\n */\nfunction createPropertyFormatter({\n  outputReferences = false,\n  outputReferenceFallbacks = false,\n  dictionary,\n  format,\n  formatting = {},\n  themeable = false\n}) {\n  let {prefix, commentStyle, indentation, separator, suffix} = Object.assign({}, defaultFormatting, formatting);\n\n  switch(format) {\n    case 'css':\n      prefix = '--';\n      indentation = '  ';\n      separator = ':';\n      break;\n    case 'sass':\n      prefix = '$';\n      commentStyle = 'short';\n      indentation = '';\n      separator = ':';\n      break;\n    case 'less':\n      prefix = '@';\n      commentStyle = 'short';\n      indentation = '';\n      separator = ':';\n      break;\n    case 'stylus':\n      prefix = '$';\n      commentStyle = 'short';\n      indentation = '';\n      separator = '=';\n      break;\n  }\n\n  return function(prop) {\n    let to_ret_prop = `${indentation}${prefix}${prop.name}${separator} `;\n    let value = prop.value;\n\n    /**\n     * A single value can have multiple references either by interpolation:\n     * \"value\": \"{size.border.width.value} solid {color.border.primary.value}\"\n     * or if the value is an object:\n     * \"value\": {\n     *    \"size\": \"{size.border.width.value}\",\n     *    \"style\": \"solid\",\n     *    \"color\": \"{color.border.primary.value\"}\n     * }\n     * This will see if there are references and if there are, replace\n     * the resolved value with the reference's name.\n     */\n    if (outputReferences && dictionary.usesReference(prop.original.value)) {\n      // Formats that use this function expect `value` to be a string\n      // or else you will get '[object Object]' in the output\n      if (typeof value === 'string') {\n        const refs = dictionary.getReferences(prop.original.value);\n        refs.forEach(ref => {\n          // value should be a string that contains the resolved reference\n          // because Style Dictionary resolved this in the resolution step.\n          // Here we are undoing that by replacing the value with\n          // the reference's name\n          if (ref.value && ref.name) {\n            value = value.replace(ref.value, function() {\n              if (format === 'css') {\n                if (outputReferenceFallbacks) {\n                  return `var(${prefix}${ref.name}, ${ref.value})`;\n                } else {\n                  return `var(${prefix}${ref.name})`;\n                }\n              } else {\n                return `${prefix}${ref.name}`;\n              }\n            });\n          }\n        });\n      }\n    }\n\n    to_ret_prop += prop.attributes.category === 'asset' ? `\"${value}\"` : value;\n\n    const themeable_prop = typeof prop.themeable === 'boolean' ? prop.themeable : themeable;\n    if (format === 'sass' && themeable_prop) {\n      to_ret_prop += ' !default';\n    }\n\n    to_ret_prop += suffix;\n\n    if (prop.comment && commentStyle !== 'none') {\n      if (commentStyle === 'short') {\n        to_ret_prop = to_ret_prop.concat(` // ${prop.comment}`);\n      } else {\n        to_ret_prop = to_ret_prop.concat(` /* ${prop.comment} */`);\n      }\n    }\n\n    return to_ret_prop;\n  }\n}\n\nmodule.exports = createPropertyFormatter;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}