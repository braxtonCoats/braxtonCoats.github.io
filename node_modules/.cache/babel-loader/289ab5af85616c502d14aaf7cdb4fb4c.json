{"ast":null,"code":"/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nconst createPropertyFormatter = require('./createPropertyFormatter');\n\nconst sortByReference = require('./sortByReference');\n\nconst defaultFormatting = {\n  lineSeparator: '\\n'\n};\n/**\n *\n * This is used to create lists of variables like Sass variables or CSS custom properties\n * @memberof module:formatHelpers\n * @param {Object} options\n * @param {String} options.format - What type of variables to output. Options are: css, sass, less, and stylus\n * @param {Object} options.dictionary - The dictionary object that gets passed to the formatter method.\n * @param {Boolean} options.outputReferences - Whether or not to output references\n * @param {Object} options.formatting - Custom formatting properties that define parts of a declaration line in code. This will get passed to `formatHelpers.createPropertyFormatter` and used for the `lineSeparator` between lines of code.\n * @param {Boolean} options.themeable [false] - Whether tokens should default to being themeable.\n * @returns {String}\n * @example\n * ```js\n * StyleDictionary.registerFormat({\n *   name: 'myCustomFormat',\n *   formatter: function({ dictionary, options }) {\n *     return formattedVariables({\n *       format: 'less',\n *       dictionary,\n *       outputReferences: options.outputReferences\n *     });\n *   }\n * });\n * ```\n */\n\nfunction formattedVariables(_ref) {\n  let {\n    format,\n    dictionary,\n    outputReferences = false,\n    formatting = {},\n    themeable = false\n  } = _ref;\n  let {\n    allTokens\n  } = dictionary;\n  let {\n    lineSeparator\n  } = Object.assign({}, defaultFormatting, formatting); // Some languages are imperative, meaning a variable has to be defined\n  // before it is used. If `outputReferences` is true, check if the token\n  // has a reference, and if it does send it to the end of the array.\n  // We also need to account for nested references, a -> b -> c. They\n  // need to be defined in reverse order: c, b, a so that the reference always\n  // comes after the definition\n\n  if (outputReferences) {\n    // note: using the spread operator here so we get a new array rather than\n    // mutating the original\n    allTokens = [...allTokens].sort(sortByReference(dictionary));\n  }\n\n  return allTokens.map(createPropertyFormatter({\n    outputReferences,\n    dictionary,\n    format,\n    formatting,\n    themeable\n  })).filter(function (strVal) {\n    return !!strVal;\n  }).join(lineSeparator);\n}\n\nmodule.exports = formattedVariables;","map":{"version":3,"names":["createPropertyFormatter","require","sortByReference","defaultFormatting","lineSeparator","formattedVariables","format","dictionary","outputReferences","formatting","themeable","allTokens","Object","assign","sort","map","filter","strVal","join","module","exports"],"sources":["/Users/braxtoncoats/Github/bcd/node_modules/style-dictionary/lib/common/formatHelpers/formattedVariables.js"],"sourcesContent":["/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\nconst createPropertyFormatter = require('./createPropertyFormatter');\nconst sortByReference = require('./sortByReference');\n\nconst defaultFormatting = {\n  lineSeparator: '\\n',\n}\n\n/**\n *\n * This is used to create lists of variables like Sass variables or CSS custom properties\n * @memberof module:formatHelpers\n * @param {Object} options\n * @param {String} options.format - What type of variables to output. Options are: css, sass, less, and stylus\n * @param {Object} options.dictionary - The dictionary object that gets passed to the formatter method.\n * @param {Boolean} options.outputReferences - Whether or not to output references\n * @param {Object} options.formatting - Custom formatting properties that define parts of a declaration line in code. This will get passed to `formatHelpers.createPropertyFormatter` and used for the `lineSeparator` between lines of code.\n * @param {Boolean} options.themeable [false] - Whether tokens should default to being themeable.\n * @returns {String}\n * @example\n * ```js\n * StyleDictionary.registerFormat({\n *   name: 'myCustomFormat',\n *   formatter: function({ dictionary, options }) {\n *     return formattedVariables({\n *       format: 'less',\n *       dictionary,\n *       outputReferences: options.outputReferences\n *     });\n *   }\n * });\n * ```\n */\nfunction formattedVariables({ format, dictionary, outputReferences = false, formatting = {}, themeable = false}) {\n  let {allTokens} = dictionary;\n\n  let {lineSeparator} = Object.assign({}, defaultFormatting, formatting);\n\n  // Some languages are imperative, meaning a variable has to be defined\n  // before it is used. If `outputReferences` is true, check if the token\n  // has a reference, and if it does send it to the end of the array.\n  // We also need to account for nested references, a -> b -> c. They\n  // need to be defined in reverse order: c, b, a so that the reference always\n  // comes after the definition\n  if (outputReferences) {\n    // note: using the spread operator here so we get a new array rather than\n    // mutating the original\n    allTokens = [...allTokens].sort(sortByReference(dictionary));\n  }\n\n  return allTokens\n    .map(createPropertyFormatter({ outputReferences, dictionary, format, formatting, themeable }))\n    .filter(function(strVal) { return !!strVal })\n    .join(lineSeparator);\n}\n\nmodule.exports = formattedVariables;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,uBAAuB,GAAGC,OAAO,CAAC,2BAAD,CAAvC;;AACA,MAAMC,eAAe,GAAGD,OAAO,CAAC,mBAAD,CAA/B;;AAEA,MAAME,iBAAiB,GAAG;EACxBC,aAAa,EAAE;AADS,CAA1B;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,kBAAT,OAAiH;EAAA,IAArF;IAAEC,MAAF;IAAUC,UAAV;IAAsBC,gBAAgB,GAAG,KAAzC;IAAgDC,UAAU,GAAG,EAA7D;IAAiEC,SAAS,GAAG;EAA7E,CAAqF;EAC/G,IAAI;IAACC;EAAD,IAAcJ,UAAlB;EAEA,IAAI;IAACH;EAAD,IAAkBQ,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBV,iBAAlB,EAAqCM,UAArC,CAAtB,CAH+G,CAK/G;EACA;EACA;EACA;EACA;EACA;;EACA,IAAID,gBAAJ,EAAsB;IACpB;IACA;IACAG,SAAS,GAAG,CAAC,GAAGA,SAAJ,EAAeG,IAAf,CAAoBZ,eAAe,CAACK,UAAD,CAAnC,CAAZ;EACD;;EAED,OAAOI,SAAS,CACbI,GADI,CACAf,uBAAuB,CAAC;IAAEQ,gBAAF;IAAoBD,UAApB;IAAgCD,MAAhC;IAAwCG,UAAxC;IAAoDC;EAApD,CAAD,CADvB,EAEJM,MAFI,CAEG,UAASC,MAAT,EAAiB;IAAE,OAAO,CAAC,CAACA,MAAT;EAAiB,CAFvC,EAGJC,IAHI,CAGCd,aAHD,CAAP;AAID;;AAEDe,MAAM,CAACC,OAAP,GAAiBf,kBAAjB"},"metadata":{},"sourceType":"script"}