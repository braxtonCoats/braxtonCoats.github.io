{"ast":null,"code":"/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nvar _ = require('../utils/es6_'),\n    usesValueReference = require('../utils/references/usesReference'),\n    getName = require('../utils/references/getName'),\n    transformProperty = require('./property'),\n    propertySetup = require('./propertySetup');\n/**\n * Applies transforms on all tokens. This\n * does not happen inline, rather it is functional\n * and returns a new object. By doing this,\n * we can perform transforms for different platforms\n * on the same style dictionary.\n * @private\n * @param {Object} obj\n * @param {Object} options\n * @param {Object} [transformationContext={}]\n * @param {Array} [path=[]]\n * @param {Object} [transformedObj={}]\n * @returns {Object}\n */\n\n\nfunction transformObject(obj, options) {\n  let transformationContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let path = arguments.length > 3 ? arguments[3] : undefined;\n  let transformedObj = arguments.length > 4 ? arguments[4] : undefined;\n  transformedObj = transformedObj || {};\n  path = path || [];\n  const {\n    transformedPropRefs = [],\n    deferredPropValueTransforms = []\n  } = transformationContext;\n\n  for (const name in obj) {\n    if (!obj.hasOwnProperty(name)) {\n      continue;\n    }\n\n    path.push(name);\n    const objProp = obj[name];\n\n    const isPlainObject = _.isPlainObject(objProp); // is the objProp a style property?\n    // {\n    //   value: \"#ababab\"\n    //   ...\n    // }\n\n\n    if (isPlainObject && 'value' in objProp) {\n      const pathName = getName(path);\n      const alreadyTransformed = transformedPropRefs.indexOf(pathName) !== -1; // If the property is already transformed, just pass assign it to the\n      // transformed object and move on.\n\n      if (alreadyTransformed) {\n        transformedObj[name] = objProp;\n        path.pop();\n        continue;\n      } // Note: propertySetup won't re-run if property has already been setup\n      // it is safe to run this multiple times on the same property.\n\n\n      const setupProperty = propertySetup(objProp, name, path); // If property has a reference, defer its transformations until later\n\n      if (usesValueReference(setupProperty.value, options)) {\n        // If property path isn't in the deferred array, add it now.\n        if (deferredPropValueTransforms.indexOf(pathName) === -1) {\n          deferredPropValueTransforms.push(pathName);\n        }\n\n        transformedObj[name] = setupProperty;\n        path.pop();\n        continue;\n      } // If we got here, the property hasn't been transformed yet and\n      // does not use a value reference. Transform the property now and assign it.\n\n\n      transformedObj[name] = transformProperty(setupProperty, options); // Remove the property path from the deferred transform list\n\n      _.pull(deferredPropValueTransforms, pathName); // Add the property path to the transformed list so we don't transform it again.\n\n\n      transformedPropRefs.push(pathName);\n    } else if (isPlainObject) {\n      // objProp is not a token -> go deeper down the object tree\n      transformedObj[name] = transformObject(objProp, options, transformationContext, path, transformedObj[name]);\n    } else {\n      // objProp is not a token or an object then it is some other data in the\n      // object we should just copy over. There might be metadata\n      // like documentation in the object that is not part of a token/property.\n      transformedObj[name] = objProp;\n    }\n\n    path.pop();\n  }\n\n  return transformedObj;\n}\n\nmodule.exports = transformObject;","map":{"version":3,"names":["_","require","usesValueReference","getName","transformProperty","propertySetup","transformObject","obj","options","transformationContext","path","transformedObj","transformedPropRefs","deferredPropValueTransforms","name","hasOwnProperty","push","objProp","isPlainObject","pathName","alreadyTransformed","indexOf","pop","setupProperty","value","pull","module","exports"],"sources":["/Users/braxtoncoats/Github/bcd/node_modules/style-dictionary/lib/transform/object.js"],"sourcesContent":["/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\nvar _ = require('../utils/es6_'),\n  usesValueReference = require('../utils/references/usesReference'),\n  getName = require('../utils/references/getName'),\n  transformProperty = require('./property'),\n  propertySetup = require('./propertySetup');\n\n/**\n * Applies transforms on all tokens. This\n * does not happen inline, rather it is functional\n * and returns a new object. By doing this,\n * we can perform transforms for different platforms\n * on the same style dictionary.\n * @private\n * @param {Object} obj\n * @param {Object} options\n * @param {Object} [transformationContext={}]\n * @param {Array} [path=[]]\n * @param {Object} [transformedObj={}]\n * @returns {Object}\n */\nfunction transformObject(obj, options, transformationContext = {}, path, transformedObj) {\n  transformedObj = transformedObj || {};\n  path = path || [];\n  const {transformedPropRefs = [], deferredPropValueTransforms = []} = transformationContext;\n\n  for (const name in obj) {\n    if (!obj.hasOwnProperty(name)) {\n      continue;\n    }\n\n    path.push(name);\n    const objProp = obj[name];\n    const isPlainObject = _.isPlainObject(objProp);\n\n    // is the objProp a style property?\n    // {\n    //   value: \"#ababab\"\n    //   ...\n    // }\n    if (isPlainObject && 'value' in objProp) {\n      const pathName = getName(path);\n      const alreadyTransformed = transformedPropRefs.indexOf(pathName) !== -1;\n\n      // If the property is already transformed, just pass assign it to the\n      // transformed object and move on.\n      if (alreadyTransformed) {\n        transformedObj[name] = objProp;\n        path.pop();\n        continue;\n      }\n\n      // Note: propertySetup won't re-run if property has already been setup\n      // it is safe to run this multiple times on the same property.\n      const setupProperty = propertySetup(objProp, name, path);\n\n      // If property has a reference, defer its transformations until later\n      if (usesValueReference(setupProperty.value, options)) {\n        // If property path isn't in the deferred array, add it now.\n        if (deferredPropValueTransforms.indexOf(pathName) === -1) {\n          deferredPropValueTransforms.push(pathName);\n        }\n\n        transformedObj[name] = setupProperty;\n        path.pop();\n        continue;\n      }\n\n      // If we got here, the property hasn't been transformed yet and\n      // does not use a value reference. Transform the property now and assign it.\n      transformedObj[name] = transformProperty(setupProperty, options);\n      // Remove the property path from the deferred transform list\n      _.pull(deferredPropValueTransforms, pathName);\n      // Add the property path to the transformed list so we don't transform it again.\n      transformedPropRefs.push(pathName);\n    } else if (isPlainObject) {\n      // objProp is not a token -> go deeper down the object tree\n      transformedObj[name] = transformObject(objProp, options, transformationContext, path, transformedObj[name]);\n    } else {\n      // objProp is not a token or an object then it is some other data in the\n      // object we should just copy over. There might be metadata\n      // like documentation in the object that is not part of a token/property.\n      transformedObj[name] = objProp;\n    }\n\n    path.pop();\n  }\n\n  return transformedObj;\n}\n\n\nmodule.exports = transformObject;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}