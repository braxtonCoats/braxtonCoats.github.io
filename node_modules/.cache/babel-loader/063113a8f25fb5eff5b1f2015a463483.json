{"ast":null,"code":"/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nconst getPath = require('./getPathFromName');\n\nconst createReferenceRegex = require('./createReferenceRegex');\n\nconst resolveReference = require('./resolveReference');\n\nconst GroupMessages = require('../groupMessages');\n/**\n * This is a helper function that is added to the dictionary object that\n * is passed to formats and actions. It will resolve a reference giving\n * you access to the token (not just the value) that a value references.\n * This allows formats to have variable references in the output. For example:\n *\n * ```css\n * --color-background-base: var(--color-core-white);\n * ```\n *\n * @memberof Dictionary\n * @param {string} value the value that contains a reference\n * @param {object[]} references array of token's references because a token's value can contain multiple references due to string interpolation\n * @returns {any}\n */\n\n\nfunction getReferences(value) {\n  let references = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  // `this` is the dictionary object passed to formats and actions\n  const self = this;\n  const regex = createReferenceRegex({}); // this will update the references array with the referenced tokens it finds.\n\n  function findReference(match, variable) {\n    // remove 'value' to access the whole token object\n    variable = variable.trim().replace('.value', ''); // Find what the value is referencing\n\n    const pathName = getPath(variable);\n    let ref = resolveReference(pathName, self.properties);\n\n    if (!ref) {\n      // fall back on _properties as it is unfiltered\n      ref = resolveReference(pathName, self._properties); // and warn the user about this\n\n      GroupMessages.add(GroupMessages.GROUP.FilteredOutputReferences, variable);\n    }\n\n    references.push(ref);\n  }\n\n  if (typeof value === 'string') {\n    // function inside .replace runs multiple times if there are multiple matches\n    value.replace(regex, findReference);\n  } // If the token's value is an object, run the replace reference\n  // on each value within that object. This mirrors the `usesReference`\n  // function which iterates over the object to see if there is a reference\n\n\n  if (typeof value === 'object') {\n    for (const key in value) {\n      if (value.hasOwnProperty(key) && typeof value[key] === 'string') {\n        value[key].replace(regex, findReference);\n      } // if it is an object, we go further down the rabbit hole\n\n\n      if (value.hasOwnProperty(key) && typeof value[key] === 'object') {\n        self.getReferences(value[key], references);\n      }\n    }\n  }\n\n  return references;\n}\n\nmodule.exports = getReferences;","map":{"version":3,"names":["getPath","require","createReferenceRegex","resolveReference","GroupMessages","getReferences","value","references","self","regex","findReference","match","variable","trim","replace","pathName","ref","properties","_properties","add","GROUP","FilteredOutputReferences","push","key","hasOwnProperty","module","exports"],"sources":["/Users/braxtoncoats/Github/bcd/node_modules/style-dictionary/lib/utils/references/getReferences.js"],"sourcesContent":["/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\nconst getPath = require('./getPathFromName');\nconst createReferenceRegex = require('./createReferenceRegex');\nconst resolveReference = require('./resolveReference');\nconst GroupMessages = require('../groupMessages');\n\n/**\n * This is a helper function that is added to the dictionary object that\n * is passed to formats and actions. It will resolve a reference giving\n * you access to the token (not just the value) that a value references.\n * This allows formats to have variable references in the output. For example:\n *\n * ```css\n * --color-background-base: var(--color-core-white);\n * ```\n *\n * @memberof Dictionary\n * @param {string} value the value that contains a reference\n * @param {object[]} references array of token's references because a token's value can contain multiple references due to string interpolation\n * @returns {any}\n */\nfunction getReferences(value, references=[]) {\n  // `this` is the dictionary object passed to formats and actions\n  const self = this;\n  const regex = createReferenceRegex({});\n\n  // this will update the references array with the referenced tokens it finds.\n  function findReference(match, variable) {\n    // remove 'value' to access the whole token object\n    variable = variable.trim().replace('.value','');\n\n    // Find what the value is referencing\n    const pathName = getPath(variable);\n\n    let ref = resolveReference(pathName, self.properties);\n    if (!ref) {\n      // fall back on _properties as it is unfiltered\n      ref = resolveReference(pathName, self._properties);\n      // and warn the user about this\n      GroupMessages.add(GroupMessages.GROUP.FilteredOutputReferences, variable);\n    }\n    references.push(ref);\n  }\n\n  if (typeof value === 'string') {\n    // function inside .replace runs multiple times if there are multiple matches\n    value.replace(regex, findReference);\n  }\n\n  // If the token's value is an object, run the replace reference\n  // on each value within that object. This mirrors the `usesReference`\n  // function which iterates over the object to see if there is a reference\n  if (typeof value === 'object') {\n    for (const key in value) {\n      if (value.hasOwnProperty(key) && typeof value[key] === 'string') {\n        value[key].replace(regex, findReference);\n      }\n      // if it is an object, we go further down the rabbit hole\n      if (value.hasOwnProperty(key) && typeof value[key] === 'object') {\n        self.getReferences(value[key], references);\n      }\n    }\n  }\n\n  return references;\n}\n\nmodule.exports = getReferences;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,mBAAD,CAAvB;;AACA,MAAMC,oBAAoB,GAAGD,OAAO,CAAC,wBAAD,CAApC;;AACA,MAAME,gBAAgB,GAAGF,OAAO,CAAC,oBAAD,CAAhC;;AACA,MAAMG,aAAa,GAAGH,OAAO,CAAC,kBAAD,CAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,aAAT,CAAuBC,KAAvB,EAA6C;EAAA,IAAfC,UAAe,uEAAJ,EAAI;EAC3C;EACA,MAAMC,IAAI,GAAG,IAAb;EACA,MAAMC,KAAK,GAAGP,oBAAoB,CAAC,EAAD,CAAlC,CAH2C,CAK3C;;EACA,SAASQ,aAAT,CAAuBC,KAAvB,EAA8BC,QAA9B,EAAwC;IACtC;IACAA,QAAQ,GAAGA,QAAQ,CAACC,IAAT,GAAgBC,OAAhB,CAAwB,QAAxB,EAAiC,EAAjC,CAAX,CAFsC,CAItC;;IACA,MAAMC,QAAQ,GAAGf,OAAO,CAACY,QAAD,CAAxB;IAEA,IAAII,GAAG,GAAGb,gBAAgB,CAACY,QAAD,EAAWP,IAAI,CAACS,UAAhB,CAA1B;;IACA,IAAI,CAACD,GAAL,EAAU;MACR;MACAA,GAAG,GAAGb,gBAAgB,CAACY,QAAD,EAAWP,IAAI,CAACU,WAAhB,CAAtB,CAFQ,CAGR;;MACAd,aAAa,CAACe,GAAd,CAAkBf,aAAa,CAACgB,KAAd,CAAoBC,wBAAtC,EAAgET,QAAhE;IACD;;IACDL,UAAU,CAACe,IAAX,CAAgBN,GAAhB;EACD;;EAED,IAAI,OAAOV,KAAP,KAAiB,QAArB,EAA+B;IAC7B;IACAA,KAAK,CAACQ,OAAN,CAAcL,KAAd,EAAqBC,aAArB;EACD,CA1B0C,CA4B3C;EACA;EACA;;;EACA,IAAI,OAAOJ,KAAP,KAAiB,QAArB,EAA+B;IAC7B,KAAK,MAAMiB,GAAX,IAAkBjB,KAAlB,EAAyB;MACvB,IAAIA,KAAK,CAACkB,cAAN,CAAqBD,GAArB,KAA6B,OAAOjB,KAAK,CAACiB,GAAD,CAAZ,KAAsB,QAAvD,EAAiE;QAC/DjB,KAAK,CAACiB,GAAD,CAAL,CAAWT,OAAX,CAAmBL,KAAnB,EAA0BC,aAA1B;MACD,CAHsB,CAIvB;;;MACA,IAAIJ,KAAK,CAACkB,cAAN,CAAqBD,GAArB,KAA6B,OAAOjB,KAAK,CAACiB,GAAD,CAAZ,KAAsB,QAAvD,EAAiE;QAC/Df,IAAI,CAACH,aAAL,CAAmBC,KAAK,CAACiB,GAAD,CAAxB,EAA+BhB,UAA/B;MACD;IACF;EACF;;EAED,OAAOA,UAAP;AACD;;AAEDkB,MAAM,CAACC,OAAP,GAAiBrB,aAAjB"},"metadata":{},"sourceType":"script"}