{"ast":null,"code":"/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nconst _ = require('./es6_'),\n      GroupMessages = require('./groupMessages'),\n      usesReference = require('./references/usesReference'),\n      getName = require('./references/getName'),\n      getPath = require('./references/getPathFromName'),\n      createReferenceRegex = require('./references/createReferenceRegex'),\n      resolveReference = require('./references/resolveReference');\n\nconst PROPERTY_REFERENCE_WARNINGS = GroupMessages.GROUP.PropertyReferenceWarnings;\nlet current_context = []; // To maintain the context to be able to test for circular definitions\n\nconst defaults = {\n  ignoreKeys: ['original'],\n  ignorePaths: []\n};\nlet updated_object, regex, options;\n\nfunction resolveObject(object, opts) {\n  options = Object.assign({}, defaults, opts);\n  updated_object = _.cloneDeep(object); // This object will be edited\n\n  regex = createReferenceRegex(options);\n\n  if (typeof object === 'object') {\n    current_context = [];\n    return traverseObj(updated_object);\n  } else {\n    throw new Error('Please pass an object in');\n  }\n}\n\nfunction traverseObj(obj) {\n  let key;\n\n  for (key in obj) {\n    if (!obj.hasOwnProperty(key)) {\n      continue;\n    } // We want to check for ignoredKeys, this is to\n    // skip over attributes that should not be\n    // mutated, like a copy of the original property.\n\n\n    if (options.ignoreKeys && options.ignoreKeys.indexOf(key) !== -1) {\n      continue;\n    }\n\n    current_context.push(key);\n\n    if (typeof obj[key] === 'object') {\n      traverseObj(obj[key]);\n    } else {\n      if (typeof obj[key] === 'string' && obj[key].indexOf('{') > -1) {\n        obj[key] = compile_value(obj[key], [getName(current_context)]);\n      }\n    }\n\n    current_context.pop();\n  }\n\n  return obj;\n}\n\nlet foundCirc = {};\n\nfunction compile_value(value, stack) {\n  let to_ret = value,\n      ref; // Replace the reference inline, but don't replace the whole string because\n  // references can be part of the value such as \"1px solid {color.border.light}\"\n\n  value.replace(regex, function (match, variable) {\n    variable = variable.trim(); // Find what the value is referencing\n\n    const pathName = getPath(variable, options);\n    const context = getName(current_context, options);\n    const refHasValue = pathName[pathName.length - 1] === 'value';\n\n    if (refHasValue && options.ignorePaths.indexOf(variable) !== -1) {\n      return value;\n    } else if (!refHasValue && options.ignorePaths.indexOf(`${variable}.value`) !== -1) {\n      return value;\n    }\n\n    stack.push(variable);\n    ref = resolveReference(pathName, updated_object); // If the reference doesn't end in 'value'\n    // and\n    // the reference points to someplace that has a `value` attribute\n    // we should take the '.value' of the reference\n    // per the W3C draft spec where references do not have .value\n    // https://design-tokens.github.io/community-group/format/#aliases-references\n\n    if (!refHasValue && ref && ref.hasOwnProperty('value')) {\n      ref = ref.value;\n    }\n\n    if (typeof ref !== 'undefined') {\n      if (typeof ref === 'string' || typeof ref === 'number') {\n        to_ret = value.replace(match, ref); // Recursive, therefore we can compute multi-layer variables like a = b, b = c, eventually a = c\n\n        if (usesReference(to_ret, regex)) {\n          var reference = to_ret.slice(1, -1); // Compare to found circular references\n\n          if (foundCirc.hasOwnProperty(reference)) {// If the current reference is a member of a circular reference, do nothing\n          } else if (stack.indexOf(reference) !== -1) {\n            // If the current stack already contains the current reference, we found a new circular reference\n            // chop down only the circular part, save it to our circular reference info, and spit out an error\n            // Get the position of the existing reference in the stack\n            var stackIndexReference = stack.indexOf(reference); // Get the portion of the stack that starts at the circular reference and brings you through until the end\n\n            var circStack = stack.slice(stackIndexReference); // For all the references in this list, add them to the list of references that end up in a circular reference\n\n            circStack.forEach(function (key) {\n              foundCirc[key] = true;\n            }); // Add our found circular reference to the end of the cycle\n\n            circStack.push(reference); // Add circ reference info to our list of warning messages\n\n            GroupMessages.add(PROPERTY_REFERENCE_WARNINGS, \"Circular definition cycle:  \" + circStack.join(', '));\n          } else {\n            to_ret = compile_value(to_ret, stack);\n          }\n        } // if evaluated value is a number and equal to the reference, we want to keep the type\n\n\n        if (typeof ref === 'number' && ref.toString() === to_ret) {\n          to_ret = ref;\n        }\n      } else {\n        // if evaluated value is not a string or number, we want to keep the type\n        to_ret = ref;\n      }\n    } else {\n      GroupMessages.add(PROPERTY_REFERENCE_WARNINGS, \"Reference doesn't exist: \" + context + \" tries to reference \" + variable + \", which is not defined\");\n      to_ret = ref;\n    }\n\n    stack.pop(variable);\n    return to_ret;\n  });\n  return to_ret;\n}\n\nmodule.exports = resolveObject;","map":{"version":3,"names":["_","require","GroupMessages","usesReference","getName","getPath","createReferenceRegex","resolveReference","PROPERTY_REFERENCE_WARNINGS","GROUP","PropertyReferenceWarnings","current_context","defaults","ignoreKeys","ignorePaths","updated_object","regex","options","resolveObject","object","opts","Object","assign","cloneDeep","traverseObj","Error","obj","key","hasOwnProperty","indexOf","push","compile_value","pop","foundCirc","value","stack","to_ret","ref","replace","match","variable","trim","pathName","context","refHasValue","length","reference","slice","stackIndexReference","circStack","forEach","add","join","toString","module","exports"],"sources":["/Users/braxtoncoats/Github/bcd/node_modules/style-dictionary/lib/utils/resolveObject.js"],"sourcesContent":["/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\nconst _ = require('./es6_'),\n    GroupMessages = require('./groupMessages'),\n    usesReference = require('./references/usesReference'),\n    getName = require('./references/getName'),\n    getPath = require('./references/getPathFromName'),\n    createReferenceRegex = require('./references/createReferenceRegex'),\n    resolveReference = require('./references/resolveReference');\n\nconst PROPERTY_REFERENCE_WARNINGS = GroupMessages.GROUP.PropertyReferenceWarnings;\n\nlet current_context = []; // To maintain the context to be able to test for circular definitions\nconst defaults = {\n  ignoreKeys: ['original'],\n  ignorePaths: [],\n};\nlet updated_object, regex, options;\n\n\nfunction resolveObject(object, opts) {\n  options = Object.assign({}, defaults, opts);\n\n  updated_object = _.cloneDeep(object);  // This object will be edited\n\n  regex = createReferenceRegex(options);\n\n  if (typeof object === 'object') {\n    current_context = [];\n    return traverseObj( updated_object );\n  } else {\n    throw new Error('Please pass an object in');\n  }\n}\n\n\n\nfunction traverseObj(obj) {\n  let key;\n\n  for (key in obj) {\n    if (!obj.hasOwnProperty(key)) {\n      continue;\n    }\n\n    // We want to check for ignoredKeys, this is to\n    // skip over attributes that should not be\n    // mutated, like a copy of the original property.\n    if (options.ignoreKeys && options.ignoreKeys.indexOf(key) !== -1) {\n      continue;\n    }\n\n    current_context.push(key);\n    if (typeof obj[key] === 'object') {\n      traverseObj( obj[key] );\n    } else {\n      if (typeof obj[key] === 'string' && obj[key].indexOf('{') > -1) {\n        obj[key] = compile_value( obj[key], [getName(current_context)] );\n      }\n    }\n    current_context.pop();\n  }\n\n  return obj;\n}\n\n\nlet foundCirc = {};\nfunction compile_value(value, stack) {\n\n  let to_ret = value, ref;\n\n  // Replace the reference inline, but don't replace the whole string because\n  // references can be part of the value such as \"1px solid {color.border.light}\"\n  value.replace(regex, function(match, variable) {\n    variable = variable.trim();\n\n    // Find what the value is referencing\n    const pathName = getPath(variable, options);\n    const context = getName(current_context, options);\n    const refHasValue = pathName[pathName.length-1] === 'value';\n\n    if (refHasValue && options.ignorePaths.indexOf(variable) !== -1) {\n      return value;\n    } else if (!refHasValue && options.ignorePaths.indexOf(`${variable}.value`) !== -1) {\n      return value;\n    }\n\n    stack.push(variable);\n\n    ref = resolveReference(pathName, updated_object);\n\n    // If the reference doesn't end in 'value'\n    // and\n    // the reference points to someplace that has a `value` attribute\n    // we should take the '.value' of the reference\n    // per the W3C draft spec where references do not have .value\n    // https://design-tokens.github.io/community-group/format/#aliases-references\n    if (!refHasValue && ref && ref.hasOwnProperty('value')) {\n      ref = ref.value;\n    }\n\n    if (typeof ref !== 'undefined') {\n      if (typeof ref === 'string' || typeof ref === 'number') {\n        to_ret = value.replace(match, ref);\n\n        // Recursive, therefore we can compute multi-layer variables like a = b, b = c, eventually a = c\n        if (usesReference(to_ret, regex)) {\n          var reference = to_ret.slice(1, -1);\n\n          // Compare to found circular references\n          if (foundCirc.hasOwnProperty(reference)) {\n            // If the current reference is a member of a circular reference, do nothing\n          }\n          else if(stack.indexOf(reference)!==-1) {\n            // If the current stack already contains the current reference, we found a new circular reference\n            // chop down only the circular part, save it to our circular reference info, and spit out an error\n\n            // Get the position of the existing reference in the stack\n            var stackIndexReference = stack.indexOf(reference);\n\n            // Get the portion of the stack that starts at the circular reference and brings you through until the end\n            var circStack = stack.slice(stackIndexReference);\n\n            // For all the references in this list, add them to the list of references that end up in a circular reference\n            circStack.forEach(function(key) { foundCirc[key] = true; });\n\n            // Add our found circular reference to the end of the cycle\n            circStack.push(reference);\n\n            // Add circ reference info to our list of warning messages\n            GroupMessages.add(\n              PROPERTY_REFERENCE_WARNINGS,\n              \"Circular definition cycle:  \" + circStack.join(', ')\n            );\n          }\n          else {\n            to_ret = compile_value( to_ret, stack );\n          }\n        }\n        // if evaluated value is a number and equal to the reference, we want to keep the type\n        if (typeof ref === 'number' && ref.toString() === to_ret) {\n          to_ret = ref;\n        }\n      } else {\n        // if evaluated value is not a string or number, we want to keep the type\n        to_ret = ref;\n      }\n    } else {\n      GroupMessages.add(\n        PROPERTY_REFERENCE_WARNINGS,\n        \"Reference doesn't exist: \" + context + \" tries to reference \" + variable + \", which is not defined\"\n      );\n      to_ret = ref;\n    }\n    stack.pop(variable);\n\n    return to_ret;\n  });\n\n  return to_ret;\n}\n\nmodule.exports = resolveObject;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}