{"ast":null,"code":"/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nvar _ = require('../utils/es6_'),\n    deepExtend = require('../utils/deepExtend'),\n    GroupMessages = require('../utils/groupMessages');\n\nvar TEMPLATE_DEPRECATION_WARNINGS = GroupMessages.GROUP.TemplateDeprecationWarnings;\nvar MISSING_TRANSFORM_ERRORS = GroupMessages.GROUP.MissingRegisterTransformErrors;\n/**\n * Takes a platform config object and returns a new one\n * that has filters, transforms, formats, and actions\n * mapped properly.\n * @private\n * @param {Object} config\n * @param {Object} dictionary\n * @param {Object} platformName (only used for error messaging)\n * @returns {Object}\n */\n\nfunction transformConfig(config, dictionary, platformName) {\n  var to_ret = _.clone(config); // The platform can define either a transformGroup or an array\n  // of transforms. If given a transformGroup that doesn't exist,\n  // it will throw an error to make the user aware that the transformGroup doesn't\n  // exist. A valid case is if the user defines neither, no transforms will be\n  // applied.\n\n\n  var transforms = [];\n\n  if (to_ret.transforms) {\n    transforms = to_ret.transforms;\n  } else if (to_ret.transformGroup) {\n    if (dictionary.transformGroup[to_ret.transformGroup]) {\n      transforms = dictionary.transformGroup[to_ret.transformGroup];\n    } else {\n      let err = `\nUnknown transformGroup \"${to_ret.transformGroup}\" found in platform \"${platformName}\":\n\"${to_ret.transformGroup}\" does not match the name of a registered transformGroup.\n`;\n      throw new Error(err);\n    }\n  } // Transforms are an array of strings that map to functions on\n  // the StyleDictionary module. We need to map the strings to\n  // the actual functions.\n\n\n  to_ret.transforms = transforms.map(function (name) {\n    if (!dictionary.transform[name]) {\n      GroupMessages.add(MISSING_TRANSFORM_ERRORS, `\"${name}\"`);\n    }\n\n    return dictionary.transform[name];\n  });\n  let missingTransformCount = GroupMessages.count(MISSING_TRANSFORM_ERRORS);\n\n  if (missingTransformCount > 0) {\n    var transform_warnings = GroupMessages.flush(MISSING_TRANSFORM_ERRORS).join(', ');\n    let err;\n\n    if (missingTransformCount == 1) {\n      err = `\nUnknown transform ${transform_warnings} found in platform \"${platformName}\":\n${transform_warnings} does not match the name of a registered transform.\n`;\n    } else {\n      err = `\nUnknown transforms ${transform_warnings} found in platform \"${platformName}\":\nNone of ${transform_warnings} match the name of a registered transform.\n`;\n    }\n\n    throw new Error(err);\n  } // Apply registered fileHeaders onto the platform options\n\n\n  if (config.options && config.options.fileHeader) {\n    const fileHeader = config.options.fileHeader;\n\n    if (typeof fileHeader === 'string') {\n      if (dictionary.fileHeader[fileHeader]) {\n        to_ret.options.fileHeader = dictionary.fileHeader[fileHeader];\n      } else {\n        throw new Error(`Can't find fileHeader: ${fileHeader}`);\n      }\n    } else if (typeof fileHeader !== 'function') {\n      throw new Error(`fileHeader must be a string or a function`);\n    } else {\n      to_ret.options.fileHeader = fileHeader;\n    }\n  }\n\n  to_ret.files = (config.files || []).map(function (file) {\n    const ext = {\n      options: {}\n    };\n\n    if (file.options && file.options.fileHeader) {\n      const fileHeader = file.options.fileHeader;\n\n      if (typeof fileHeader === 'string') {\n        if (dictionary.fileHeader[fileHeader]) {\n          ext.options.fileHeader = dictionary.fileHeader[fileHeader];\n        } else {\n          throw new Error(`Can't find fileHeader: ${fileHeader}`);\n        }\n      } else if (typeof fileHeader !== 'function') {\n        throw new Error(`fileHeader must be a string or a function`);\n      } else {\n        ext.options.fileHeader = fileHeader;\n      }\n    }\n\n    if (file.filter) {\n      if (typeof file.filter === 'string') {\n        if (dictionary.filter[file.filter]) {\n          ext.filter = dictionary.filter[file.filter];\n        } else {\n          throw new Error('Can\\'t find filter: ' + file.filter);\n        }\n      } else if (typeof file.filter === 'object') {\n        ext.filter = _.matches(file.filter);\n      } else if (typeof file.filter === 'function') {\n        ext.filter = file.filter;\n      } else {\n        throw new Error('Filter format not valid: ' + typeof file.filter);\n      }\n    }\n\n    if (file.template) {\n      if (dictionary.format[file.template]) {\n        GroupMessages.add(TEMPLATE_DEPRECATION_WARNINGS, `${file.destination} (template: ${file.template})`);\n        ext.format = dictionary.format[file.template];\n      } else {\n        throw new Error('Can\\'t find template: ' + file.template);\n      }\n    } else if (file.format) {\n      if (dictionary.format[file.format]) {\n        ext.format = dictionary.format[file.format];\n      } else {\n        throw new Error('Can\\'t find format: ' + file.format);\n      }\n    } else {\n      throw new Error('Please supply a format for file: ' + JSON.stringify(file));\n    }\n\n    return deepExtend([{}, file, ext]);\n  });\n  to_ret.actions = (config.actions || []).map(function (action) {\n    if (typeof dictionary.action[action].undo !== 'function') {\n      console.warn(action + \" action does not have a clean function!\");\n    }\n\n    return dictionary.action[action];\n  });\n  return to_ret;\n}\n\nmodule.exports = transformConfig;","map":{"version":3,"names":["_","require","deepExtend","GroupMessages","TEMPLATE_DEPRECATION_WARNINGS","GROUP","TemplateDeprecationWarnings","MISSING_TRANSFORM_ERRORS","MissingRegisterTransformErrors","transformConfig","config","dictionary","platformName","to_ret","clone","transforms","transformGroup","err","Error","map","name","transform","add","missingTransformCount","count","transform_warnings","flush","join","options","fileHeader","files","file","ext","filter","matches","template","format","destination","JSON","stringify","actions","action","undo","console","warn","module","exports"],"sources":["/Users/braxtoncoats/Github/bcd/node_modules/style-dictionary/lib/transform/config.js"],"sourcesContent":["/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\nvar _     = require('../utils/es6_'),\n    deepExtend = require('../utils/deepExtend'),\n    GroupMessages = require('../utils/groupMessages');\n\nvar TEMPLATE_DEPRECATION_WARNINGS = GroupMessages.GROUP.TemplateDeprecationWarnings;\nvar MISSING_TRANSFORM_ERRORS = GroupMessages.GROUP.MissingRegisterTransformErrors;\n\n/**\n * Takes a platform config object and returns a new one\n * that has filters, transforms, formats, and actions\n * mapped properly.\n * @private\n * @param {Object} config\n * @param {Object} dictionary\n * @param {Object} platformName (only used for error messaging)\n * @returns {Object}\n */\nfunction transformConfig(config, dictionary, platformName) {\n  var to_ret = _.clone(config);\n\n  // The platform can define either a transformGroup or an array\n  // of transforms. If given a transformGroup that doesn't exist,\n  // it will throw an error to make the user aware that the transformGroup doesn't\n  // exist. A valid case is if the user defines neither, no transforms will be\n  // applied.\n  var transforms = [];\n  if (to_ret.transforms) {\n    transforms = to_ret.transforms;\n  } else if (to_ret.transformGroup) {\n    if (dictionary.transformGroup[to_ret.transformGroup]) {\n      transforms = dictionary.transformGroup[to_ret.transformGroup];\n    } else {\n      let err = `\nUnknown transformGroup \"${to_ret.transformGroup}\" found in platform \"${platformName}\":\n\"${to_ret.transformGroup}\" does not match the name of a registered transformGroup.\n`;\n      throw new Error(err);\n    }\n  }\n\n  // Transforms are an array of strings that map to functions on\n  // the StyleDictionary module. We need to map the strings to\n  // the actual functions.\n  to_ret.transforms = transforms.map(function(name) {\n    if(!dictionary.transform[name]) {\n      GroupMessages.add(\n        MISSING_TRANSFORM_ERRORS,\n        `\"${name}\"`\n      );\n    }\n    return dictionary.transform[name];\n  });\n\n  let missingTransformCount = GroupMessages.count(MISSING_TRANSFORM_ERRORS);\n  if(missingTransformCount > 0) {\n    var transform_warnings = GroupMessages.flush(MISSING_TRANSFORM_ERRORS).join(', ');\n    let err;\n\n    if(missingTransformCount==1) {\n      err = `\nUnknown transform ${transform_warnings} found in platform \"${platformName}\":\n${transform_warnings} does not match the name of a registered transform.\n`;\n    }\n    else {\n        err = `\nUnknown transforms ${transform_warnings} found in platform \"${platformName}\":\nNone of ${transform_warnings} match the name of a registered transform.\n`;\n    }\n\n    throw new Error(err);\n  }\n\n  // Apply registered fileHeaders onto the platform options\n  if (config.options && config.options.fileHeader) {\n    const fileHeader = config.options.fileHeader;\n    if (typeof fileHeader === 'string') {\n      if (dictionary.fileHeader[fileHeader]) {\n        to_ret.options.fileHeader = dictionary.fileHeader[fileHeader];\n      } else {\n        throw new Error(`Can't find fileHeader: ${fileHeader}`);\n      }\n    } else if (typeof fileHeader !== 'function') {\n      throw new Error(`fileHeader must be a string or a function`)\n    } else {\n      to_ret.options.fileHeader = fileHeader;\n    }\n  }\n\n  to_ret.files = (config.files || []).map(function(file) {\n    const ext = { options: {} };\n    if (file.options && file.options.fileHeader) {\n      const fileHeader = file.options.fileHeader;\n      if (typeof fileHeader === 'string') {\n        if (dictionary.fileHeader[fileHeader]) {\n          ext.options.fileHeader = dictionary.fileHeader[fileHeader];\n        } else {\n          throw new Error(`Can't find fileHeader: ${fileHeader}`);\n        }\n      } else if (typeof fileHeader !== 'function') {\n        throw new Error(`fileHeader must be a string or a function`)\n      } else {\n        ext.options.fileHeader = fileHeader;\n      }\n    }\n\n    if (file.filter) {\n      if(typeof file.filter === 'string') {\n        if (dictionary.filter[file.filter]) {\n          ext.filter = dictionary.filter[file.filter];\n        } else {\n          throw new Error('Can\\'t find filter: ' + file.filter);\n        }\n      } else if (typeof file.filter === 'object') {\n        ext.filter =  _.matches(file.filter);\n      } else if (typeof file.filter === 'function') {\n        ext.filter = file.filter;\n      } else {\n        throw new Error('Filter format not valid: ' + typeof file.filter);\n      }\n    }\n\n    if (file.template) {\n      if (dictionary.format[file.template]) {\n        GroupMessages.add(\n          TEMPLATE_DEPRECATION_WARNINGS,\n          `${file.destination} (template: ${file.template})`\n        );\n        ext.format = dictionary.format[file.template];\n      } else {\n        throw new Error('Can\\'t find template: ' + file.template);\n      }\n    } else if (file.format) {\n      if (dictionary.format[file.format]) {\n        ext.format = dictionary.format[file.format];\n      } else {\n        throw new Error('Can\\'t find format: ' + file.format);\n      }\n    } else {\n      throw new Error('Please supply a format for file: ' + JSON.stringify(file));\n    }\n    return deepExtend([{}, file, ext]);\n  });\n\n  to_ret.actions = (config.actions || []).map(function(action) {\n    if (typeof dictionary.action[action].undo !== 'function') {\n      console.warn(action + \" action does not have a clean function!\");\n    }\n    return dictionary.action[action];\n  });\n\n  return to_ret;\n}\n\nmodule.exports = transformConfig;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}