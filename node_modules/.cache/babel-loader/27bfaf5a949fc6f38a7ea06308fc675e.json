{"ast":null,"code":"/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nconst resolveObject = require('./utils/resolveObject'),\n      getName = require('./utils/references/getName'),\n      transformObject = require('./transform/object'),\n      transformConfig = require('./transform/config'),\n      GroupMessages = require('./utils/groupMessages');\n\nconst PROPERTY_REFERENCE_WARNINGS = GroupMessages.GROUP.PropertyReferenceWarnings;\n/**\n * Exports a tokens object with applied\n * platform transforms.\n *\n * This is useful if you want to use a style\n * dictionary in JS build tools like webpack.\n *\n * @static\n * @memberof module:style-dictionary\n * @param {String} platform - The platform to be exported.\n * Must be defined on the style dictionary.\n * @returns {Object}\n */\n\nfunction exportPlatform(platform) {\n  if (!platform || !this.options.platforms[platform]) {\n    throw new Error('Please supply a valid platform');\n  } // We don't want to mutate the original object\n\n\n  const platformConfig = transformConfig(this.options.platforms[platform], this);\n  let exportableResult = this.properties; // list keeping paths of props with applied value transformations\n\n  const transformedPropRefs = []; // list keeping paths of props that had references in it, and therefore\n  // could not (yet) have transformed\n\n  const deferredPropValueTransforms = [];\n  const transformationContext = {\n    transformedPropRefs,\n    deferredPropValueTransforms\n  };\n  let deferredPropCount = 0;\n  let finished;\n\n  while (typeof finished === \"undefined\") {\n    // We keep up transforming and resolving until all props are resolved\n    // and every defined transformation was executed. Remember: transformations\n    // can only be executed, if the value to be transformed, has no references\n    // in it. So resolving may lead to enable further transformations, and sub\n    // sequent resolving may enable even more transformations - and so on.\n    // So we keep this loop running until sub sequent transformations are ineffective.\n    //\n    // Take the following example:\n    //\n    // color.brand = {\n    //   value: \"{color.base.green}\"\n    // }\n    //\n    // color.background.button.primary.base = {\n    //   value: \"{color.brand.value}\",\n    //   color: {\n    //     desaturate: 0.5\n    //   }\n    // }\n    //\n    // color.background.button.primary.hover = {\n    //   value: \"{color.background.button.primary.base}\",\n    //   color: {\n    //     darken: 0.2\n    //   }\n    // }\n    //\n    // As you can see 'color.background.button.primary.hover' is a variation\n    // of 'color.background.button.primary.base' which is a variation of\n    // 'color.base.green'. These transitive references are solved by running\n    // this loop until all properties are transformed and resolved.\n    // We need to transform the object before we resolve the\n    // variable names because if a value contains concatenated\n    // values like \"1px solid {color.border.base}\" we want to\n    // transform the original value (color.border.base) before\n    // replacing that value in the string.\n    const transformed = transformObject(exportableResult, platformConfig, transformationContext); // referenced values, that have not (yet) been transformed should be excluded from resolving\n\n    const ignorePathsToResolve = deferredPropValueTransforms.map(p => getName([p, 'value']));\n    exportableResult = resolveObject(transformed, {\n      ignorePaths: ignorePathsToResolve\n    });\n    const newDeferredPropCount = deferredPropValueTransforms.length; // nothing left to transform -> ready\n\n    if (newDeferredPropCount === 0) {\n      finished = true; // or deferred count doesn't go down, that means there\n      // is a circular reference -> ready (but errored)\n    } else if (deferredPropCount === newDeferredPropCount) {\n      // if we didn't resolve any deferred references then we have a circular reference\n      // the resolveObject method will find the circular references\n      // we do this in case there are multiple circular references\n      resolveObject(transformed);\n      finished = true;\n    } else {\n      // neither of these things, keep going.\n      deferredPropCount = newDeferredPropCount;\n    }\n  }\n\n  if (GroupMessages.count(PROPERTY_REFERENCE_WARNINGS) > 0) {\n    const warnings = GroupMessages.flush(PROPERTY_REFERENCE_WARNINGS).join('\\n');\n    console.log(`\\n${PROPERTY_REFERENCE_WARNINGS}:\\n${warnings}\\n\\n`);\n    throw new Error('Problems were found when trying to resolve property references');\n  }\n\n  return exportableResult;\n}\n\nmodule.exports = exportPlatform;","map":{"version":3,"names":["resolveObject","require","getName","transformObject","transformConfig","GroupMessages","PROPERTY_REFERENCE_WARNINGS","GROUP","PropertyReferenceWarnings","exportPlatform","platform","options","platforms","Error","platformConfig","exportableResult","properties","transformedPropRefs","deferredPropValueTransforms","transformationContext","deferredPropCount","finished","transformed","ignorePathsToResolve","map","p","ignorePaths","newDeferredPropCount","length","count","warnings","flush","join","console","log","module","exports"],"sources":["/Users/braxtoncoats/Github/bcd/node_modules/style-dictionary/lib/exportPlatform.js"],"sourcesContent":["/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\nconst resolveObject = require('./utils/resolveObject'),\n    getName = require('./utils/references/getName'),\n    transformObject = require('./transform/object'),\n    transformConfig = require('./transform/config'),\n    GroupMessages = require('./utils/groupMessages');\n\nconst PROPERTY_REFERENCE_WARNINGS = GroupMessages.GROUP.PropertyReferenceWarnings;\n\n/**\n * Exports a tokens object with applied\n * platform transforms.\n *\n * This is useful if you want to use a style\n * dictionary in JS build tools like webpack.\n *\n * @static\n * @memberof module:style-dictionary\n * @param {String} platform - The platform to be exported.\n * Must be defined on the style dictionary.\n * @returns {Object}\n */\nfunction exportPlatform(platform) {\n  if (!platform || !this.options.platforms[platform]) {\n    throw new Error('Please supply a valid platform');\n  }\n\n  // We don't want to mutate the original object\n  const platformConfig = transformConfig(this.options.platforms[platform], this);\n\n  let exportableResult = this.properties;\n\n  // list keeping paths of props with applied value transformations\n  const transformedPropRefs = [];\n  // list keeping paths of props that had references in it, and therefore\n  // could not (yet) have transformed\n  const deferredPropValueTransforms = [];\n\n  const transformationContext = {\n    transformedPropRefs,\n    deferredPropValueTransforms\n  };\n\n  let deferredPropCount = 0;\n  let finished;\n\n  while(typeof finished === \"undefined\") {\n    // We keep up transforming and resolving until all props are resolved\n    // and every defined transformation was executed. Remember: transformations\n    // can only be executed, if the value to be transformed, has no references\n    // in it. So resolving may lead to enable further transformations, and sub\n    // sequent resolving may enable even more transformations - and so on.\n    // So we keep this loop running until sub sequent transformations are ineffective.\n    //\n    // Take the following example:\n    //\n    // color.brand = {\n    //   value: \"{color.base.green}\"\n    // }\n    //\n    // color.background.button.primary.base = {\n    //   value: \"{color.brand.value}\",\n    //   color: {\n    //     desaturate: 0.5\n    //   }\n    // }\n    //\n    // color.background.button.primary.hover = {\n    //   value: \"{color.background.button.primary.base}\",\n    //   color: {\n    //     darken: 0.2\n    //   }\n    // }\n    //\n    // As you can see 'color.background.button.primary.hover' is a variation\n    // of 'color.background.button.primary.base' which is a variation of\n    // 'color.base.green'. These transitive references are solved by running\n    // this loop until all properties are transformed and resolved.\n\n    // We need to transform the object before we resolve the\n    // variable names because if a value contains concatenated\n    // values like \"1px solid {color.border.base}\" we want to\n    // transform the original value (color.border.base) before\n    // replacing that value in the string.\n    const transformed = transformObject(exportableResult, platformConfig, transformationContext);\n\n    // referenced values, that have not (yet) been transformed should be excluded from resolving\n    const ignorePathsToResolve = deferredPropValueTransforms.map(p => getName([p, 'value']));\n    exportableResult = resolveObject(transformed, {ignorePaths: ignorePathsToResolve});\n\n    const newDeferredPropCount = deferredPropValueTransforms.length;\n\n    // nothing left to transform -> ready\n    if (newDeferredPropCount === 0) {\n      finished = true;\n    // or deferred count doesn't go down, that means there\n    // is a circular reference -> ready (but errored)\n    } else if (deferredPropCount === newDeferredPropCount) {\n      // if we didn't resolve any deferred references then we have a circular reference\n      // the resolveObject method will find the circular references\n      // we do this in case there are multiple circular references\n      resolveObject(transformed);\n      finished = true;\n    } else {\n      // neither of these things, keep going.\n      deferredPropCount = newDeferredPropCount;\n    }\n  }\n\n  if (GroupMessages.count(PROPERTY_REFERENCE_WARNINGS) > 0) {\n    const warnings = GroupMessages.flush(PROPERTY_REFERENCE_WARNINGS).join('\\n');\n    console.log(`\\n${PROPERTY_REFERENCE_WARNINGS}:\\n${warnings}\\n\\n`);\n    throw new Error('Problems were found when trying to resolve property references');\n  }\n\n  return exportableResult;\n}\n\n\nmodule.exports = exportPlatform;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,aAAa,GAAGC,OAAO,CAAC,uBAAD,CAA7B;AAAA,MACIC,OAAO,GAAGD,OAAO,CAAC,4BAAD,CADrB;AAAA,MAEIE,eAAe,GAAGF,OAAO,CAAC,oBAAD,CAF7B;AAAA,MAGIG,eAAe,GAAGH,OAAO,CAAC,oBAAD,CAH7B;AAAA,MAIII,aAAa,GAAGJ,OAAO,CAAC,uBAAD,CAJ3B;;AAMA,MAAMK,2BAA2B,GAAGD,aAAa,CAACE,KAAd,CAAoBC,yBAAxD;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,cAAT,CAAwBC,QAAxB,EAAkC;EAChC,IAAI,CAACA,QAAD,IAAa,CAAC,KAAKC,OAAL,CAAaC,SAAb,CAAuBF,QAAvB,CAAlB,EAAoD;IAClD,MAAM,IAAIG,KAAJ,CAAU,gCAAV,CAAN;EACD,CAH+B,CAKhC;;;EACA,MAAMC,cAAc,GAAGV,eAAe,CAAC,KAAKO,OAAL,CAAaC,SAAb,CAAuBF,QAAvB,CAAD,EAAmC,IAAnC,CAAtC;EAEA,IAAIK,gBAAgB,GAAG,KAAKC,UAA5B,CARgC,CAUhC;;EACA,MAAMC,mBAAmB,GAAG,EAA5B,CAXgC,CAYhC;EACA;;EACA,MAAMC,2BAA2B,GAAG,EAApC;EAEA,MAAMC,qBAAqB,GAAG;IAC5BF,mBAD4B;IAE5BC;EAF4B,CAA9B;EAKA,IAAIE,iBAAiB,GAAG,CAAxB;EACA,IAAIC,QAAJ;;EAEA,OAAM,OAAOA,QAAP,KAAoB,WAA1B,EAAuC;IACrC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA,MAAMC,WAAW,GAAGnB,eAAe,CAACY,gBAAD,EAAmBD,cAAnB,EAAmCK,qBAAnC,CAAnC,CAtCqC,CAwCrC;;IACA,MAAMI,oBAAoB,GAAGL,2BAA2B,CAACM,GAA5B,CAAgCC,CAAC,IAAIvB,OAAO,CAAC,CAACuB,CAAD,EAAI,OAAJ,CAAD,CAA5C,CAA7B;IACAV,gBAAgB,GAAGf,aAAa,CAACsB,WAAD,EAAc;MAACI,WAAW,EAAEH;IAAd,CAAd,CAAhC;IAEA,MAAMI,oBAAoB,GAAGT,2BAA2B,CAACU,MAAzD,CA5CqC,CA8CrC;;IACA,IAAID,oBAAoB,KAAK,CAA7B,EAAgC;MAC9BN,QAAQ,GAAG,IAAX,CAD8B,CAEhC;MACA;IACC,CAJD,MAIO,IAAID,iBAAiB,KAAKO,oBAA1B,EAAgD;MACrD;MACA;MACA;MACA3B,aAAa,CAACsB,WAAD,CAAb;MACAD,QAAQ,GAAG,IAAX;IACD,CANM,MAMA;MACL;MACAD,iBAAiB,GAAGO,oBAApB;IACD;EACF;;EAED,IAAItB,aAAa,CAACwB,KAAd,CAAoBvB,2BAApB,IAAmD,CAAvD,EAA0D;IACxD,MAAMwB,QAAQ,GAAGzB,aAAa,CAAC0B,KAAd,CAAoBzB,2BAApB,EAAiD0B,IAAjD,CAAsD,IAAtD,CAAjB;IACAC,OAAO,CAACC,GAAR,CAAa,KAAI5B,2BAA4B,MAAKwB,QAAS,MAA3D;IACA,MAAM,IAAIjB,KAAJ,CAAU,gEAAV,CAAN;EACD;;EAED,OAAOE,gBAAP;AACD;;AAGDoB,MAAM,CAACC,OAAP,GAAiB3B,cAAjB"},"metadata":{},"sourceType":"script"}