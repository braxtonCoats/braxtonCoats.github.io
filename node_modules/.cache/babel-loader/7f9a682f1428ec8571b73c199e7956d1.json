{"ast":null,"code":"/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nvar path = require('path'),\n    fs = require('fs-extra'),\n    chalk = require('chalk'),\n    filterProperties = require('./filterProperties'),\n    GroupMessages = require('./utils/groupMessages');\n\nconst createFormatArgs = require('./utils/createFormatArgs');\n/**\n * Takes the style property object and a format and returns a\n * string that can be written to a file.\n * @memberOf StyleDictionary\n * @param {Object} file\n * @param {Object} platform\n * @param {Object} dictionary\n * @returns {null}\n */\n\n\nfunction buildFile() {\n  let file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let platform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let dictionary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    destination,\n    filter,\n    format\n  } = file || {};\n  if (typeof format !== 'function') throw new Error('Please enter a valid file format');\n  if (typeof destination !== 'string') throw new Error('Please enter a valid destination'); // get if the format is nested, this needs to be done before\n  // the function is bound\n\n  const nested = format.nested; // to maintain backwards compatibility we bind the format to the file object\n\n  format = format.bind(file);\n  var fullDestination = destination; // if there is a build path, prepend the full destination with it\n\n  if (platform.buildPath) {\n    fullDestination = platform.buildPath + fullDestination;\n  }\n\n  var dirname = path.dirname(fullDestination);\n  if (!fs.existsSync(dirname)) fs.mkdirsSync(dirname);\n  const filteredProperties = filterProperties(dictionary, filter);\n  const filteredDictionary = Object.assign({}, dictionary, {\n    properties: filteredProperties.properties,\n    allProperties: filteredProperties.allProperties,\n    tokens: filteredProperties.properties,\n    allTokens: filteredProperties.allProperties,\n    // keep the unfiltered properties object for reference resolution\n    _properties: dictionary.properties\n  }); // if properties object is empty, return without creating a file\n\n  if (filteredProperties.hasOwnProperty('properties') && Object.keys(filteredProperties.properties).length === 0 && filteredProperties.properties.constructor === Object) {\n    let warnNoFile = `No properties for ${destination}. File not created.`;\n    console.log(chalk.keyword('darkorange')(warnNoFile));\n    return null;\n  } // Check for property name Collisions\n\n\n  var nameCollisionObj = {};\n  filteredProperties.allProperties && filteredProperties.allProperties.forEach(propertyData => {\n    let propertyName = propertyData.name;\n\n    if (!nameCollisionObj[propertyName]) {\n      nameCollisionObj[propertyName] = [];\n    }\n\n    nameCollisionObj[propertyName].push(propertyData);\n  });\n  var PROPERTY_NAME_COLLISION_WARNINGS = GroupMessages.GROUP.PropertyNameCollisionWarnings + \":\" + destination;\n  GroupMessages.clear(PROPERTY_NAME_COLLISION_WARNINGS);\n  Object.keys(nameCollisionObj).forEach(propertyName => {\n    if (nameCollisionObj[propertyName].length > 1) {\n      let collisions = nameCollisionObj[propertyName].map(properties => {\n        let propertyPathText = chalk.keyword('orangered')(properties.path.join('.'));\n        let valueText = chalk.keyword('darkorange')(properties.value);\n        return propertyPathText + '   ' + valueText;\n      }).join('\\n        ');\n      GroupMessages.add(PROPERTY_NAME_COLLISION_WARNINGS, `Output name ${chalk.keyword('orangered').bold(propertyName)} was generated by:\\n        ${collisions}`);\n    }\n  });\n  let propertyNamesCollisionCount = GroupMessages.count(PROPERTY_NAME_COLLISION_WARNINGS);\n  fs.writeFileSync(fullDestination, format(createFormatArgs({\n    dictionary: filteredDictionary,\n    platform,\n    file\n  }), platform, file));\n  let filteredReferencesCount = GroupMessages.count(GroupMessages.GROUP.FilteredOutputReferences); // don't show name collision warnings for nested type formats\n  // because they are not relevant.\n\n  if ((nested || propertyNamesCollisionCount === 0) && filteredReferencesCount === 0) {\n    console.log(chalk.bold.green(`✔︎ ${fullDestination}`));\n  } else {\n    console.log(`⚠️ ${fullDestination}`);\n\n    if (propertyNamesCollisionCount > 0) {\n      let propertyNamesCollisionWarnings = GroupMessages.fetchMessages(PROPERTY_NAME_COLLISION_WARNINGS).join('\\n    ');\n      let title = `While building ${chalk.keyword('orangered').bold(destination)}, token collisions were found; output may be unexpected.`;\n      let help = chalk.keyword('orange')(['This many-to-one issue is usually caused by some combination of:', '* conflicting or similar paths/names in property definitions', '* platform transforms/transformGroups affecting names, especially when removing specificity', '* overly inclusive file filters'].join('\\n    '));\n      let warn = `${title}\\n    ${propertyNamesCollisionWarnings}\\n${help}`;\n      console.log(chalk.keyword('darkorange').bold(warn));\n    }\n\n    if (filteredReferencesCount > 0) {\n      let filteredReferencesWarnings = GroupMessages.flush(GroupMessages.GROUP.FilteredOutputReferences).join('\\n    ');\n      let title = `While building ${chalk.keyword('orangered').bold(destination)}, filtered out token references were found; output may be unexpected. Here are the references that are used but not defined in the file`;\n      let help = chalk.keyword('orange')(['This is caused when combining a filter and `outputReferences`.'].join('\\n    '));\n      let warn = `${title}\\n    ${filteredReferencesWarnings}\\n${help}`;\n      console.log(chalk.keyword('darkorange').bold(warn));\n    }\n  }\n}\n\nmodule.exports = buildFile;","map":{"version":3,"names":["path","require","fs","chalk","filterProperties","GroupMessages","createFormatArgs","buildFile","file","platform","dictionary","destination","filter","format","Error","nested","bind","fullDestination","buildPath","dirname","existsSync","mkdirsSync","filteredProperties","filteredDictionary","Object","assign","properties","allProperties","tokens","allTokens","_properties","hasOwnProperty","keys","length","constructor","warnNoFile","console","log","keyword","nameCollisionObj","forEach","propertyData","propertyName","name","push","PROPERTY_NAME_COLLISION_WARNINGS","GROUP","PropertyNameCollisionWarnings","clear","collisions","map","propertyPathText","join","valueText","value","add","bold","propertyNamesCollisionCount","count","writeFileSync","filteredReferencesCount","FilteredOutputReferences","green","propertyNamesCollisionWarnings","fetchMessages","title","help","warn","filteredReferencesWarnings","flush","module","exports"],"sources":["/Users/braxtoncoats/Github/bcd/node_modules/style-dictionary/lib/buildFile.js"],"sourcesContent":["/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\nvar path = require('path'),\n    fs   = require('fs-extra'),\n    chalk = require('chalk'),\n    filterProperties = require('./filterProperties'),\n    GroupMessages = require('./utils/groupMessages');\n\nconst createFormatArgs = require('./utils/createFormatArgs');\n\n/**\n * Takes the style property object and a format and returns a\n * string that can be written to a file.\n * @memberOf StyleDictionary\n * @param {Object} file\n * @param {Object} platform\n * @param {Object} dictionary\n * @returns {null}\n */\nfunction buildFile(file = {}, platform = {}, dictionary = {}) {\n  var { destination, filter, format } = file || {};\n\n  if (typeof format !== 'function')\n    throw new Error('Please enter a valid file format');\n  if (typeof destination !== 'string')\n    throw new Error('Please enter a valid destination');\n\n  // get if the format is nested, this needs to be done before\n  // the function is bound\n  const nested = format.nested;\n  // to maintain backwards compatibility we bind the format to the file object\n  format = format.bind(file);\n  var fullDestination = destination;\n\n  // if there is a build path, prepend the full destination with it\n  if (platform.buildPath) {\n    fullDestination = platform.buildPath + fullDestination;\n  }\n\n  var dirname = path.dirname(fullDestination);\n  if (!fs.existsSync(dirname))\n    fs.mkdirsSync(dirname);\n\n  const filteredProperties = filterProperties(dictionary, filter);\n  const filteredDictionary = Object.assign({}, dictionary, {\n    properties: filteredProperties.properties,\n    allProperties: filteredProperties.allProperties,\n    tokens: filteredProperties.properties,\n    allTokens: filteredProperties.allProperties,\n    // keep the unfiltered properties object for reference resolution\n    _properties: dictionary.properties\n  });\n\n  // if properties object is empty, return without creating a file\n  if (\n    filteredProperties.hasOwnProperty('properties') &&\n    Object.keys(filteredProperties.properties).length === 0 &&\n    filteredProperties.properties.constructor === Object\n  ) {\n    let warnNoFile = `No properties for ${destination}. File not created.`;\n    console.log(chalk.keyword('darkorange')(warnNoFile));\n    return null;\n  }\n\n  // Check for property name Collisions\n  var nameCollisionObj = {};\n  filteredProperties.allProperties && filteredProperties.allProperties.forEach((propertyData) => {\n    let propertyName = propertyData.name;\n    if(!nameCollisionObj[propertyName]) {\n      nameCollisionObj[propertyName] = [];\n    }\n    nameCollisionObj[propertyName].push(propertyData);\n  });\n\n  var PROPERTY_NAME_COLLISION_WARNINGS = GroupMessages.GROUP.PropertyNameCollisionWarnings + \":\" + destination;\n  GroupMessages.clear(PROPERTY_NAME_COLLISION_WARNINGS);\n  Object.keys(nameCollisionObj).forEach((propertyName) => {\n    if(nameCollisionObj[propertyName].length > 1) {\n      let collisions = nameCollisionObj[propertyName].map((properties) => {\n        let propertyPathText = chalk.keyword('orangered')(properties.path.join('.'));\n        let valueText = chalk.keyword('darkorange')(properties.value);\n        return propertyPathText + '   ' + valueText;\n      }).join('\\n        ');\n      GroupMessages.add(\n        PROPERTY_NAME_COLLISION_WARNINGS,\n        `Output name ${chalk.keyword('orangered').bold(propertyName)} was generated by:\\n        ${collisions}`\n      );\n    }\n  });\n\n  let propertyNamesCollisionCount = GroupMessages.count(PROPERTY_NAME_COLLISION_WARNINGS);\n  fs.writeFileSync(fullDestination, format(createFormatArgs({\n    dictionary: filteredDictionary,\n    platform,\n    file\n  }), platform, file));\n\n  let filteredReferencesCount = GroupMessages.count(GroupMessages.GROUP.FilteredOutputReferences);\n\n  // don't show name collision warnings for nested type formats\n  // because they are not relevant.\n  if ((nested || propertyNamesCollisionCount === 0) && filteredReferencesCount === 0) {\n    console.log( chalk.bold.green(`✔︎ ${fullDestination}`) );\n  } else {\n    console.log( `⚠️ ${fullDestination}`);\n    if (propertyNamesCollisionCount > 0) {\n      let propertyNamesCollisionWarnings = GroupMessages.fetchMessages(PROPERTY_NAME_COLLISION_WARNINGS).join('\\n    ');\n      let title = `While building ${chalk.keyword('orangered').bold(destination)}, token collisions were found; output may be unexpected.`;\n      let help = chalk.keyword('orange')([\n        'This many-to-one issue is usually caused by some combination of:',\n            '* conflicting or similar paths/names in property definitions',\n            '* platform transforms/transformGroups affecting names, especially when removing specificity',\n            '* overly inclusive file filters',\n      ].join('\\n    '));\n      let warn = `${title}\\n    ${propertyNamesCollisionWarnings}\\n${help}`;\n      console.log(chalk.keyword('darkorange').bold(warn));\n    }\n\n    if (filteredReferencesCount > 0) {\n      let filteredReferencesWarnings = GroupMessages.flush(GroupMessages.GROUP.FilteredOutputReferences).join('\\n    ');\n      let title = `While building ${chalk.keyword('orangered').bold(destination)}, filtered out token references were found; output may be unexpected. Here are the references that are used but not defined in the file`;\n      let help = chalk.keyword('orange')([\n        'This is caused when combining a filter and `outputReferences`.',\n      ].join('\\n    '));\n      let warn = `${title}\\n    ${filteredReferencesWarnings}\\n${help}`;\n      console.log(chalk.keyword('darkorange').bold(warn));\n    }\n  }\n}\n\n\nmodule.exports = buildFile;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}