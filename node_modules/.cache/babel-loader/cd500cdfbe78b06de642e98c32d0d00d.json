{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { createScanner } from './scanner';\nvar ParseOptions;\n\n(function (ParseOptions) {\n  ParseOptions.DEFAULT = {\n    allowTrailingComma: false\n  };\n})(ParseOptions || (ParseOptions = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\n\n\nexport function getLocation(text, position) {\n  var segments = []; // strings or numbers\n\n  var earlyReturnException = new Object();\n  var previousNode = undefined;\n  var previousNodeInst = {\n    value: {},\n    offset: 0,\n    length: 0,\n    type: 'object',\n    parent: undefined\n  };\n  var isAtPropertyKey = false;\n\n  function setPreviousNode(value, offset, length, type) {\n    previousNodeInst.value = value;\n    previousNodeInst.offset = offset;\n    previousNodeInst.length = length;\n    previousNodeInst.type = type;\n    previousNodeInst.colonOffset = undefined;\n    previousNode = previousNodeInst;\n  }\n\n  try {\n    visit(text, {\n      onObjectBegin: function (offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        previousNode = undefined;\n        isAtPropertyKey = position > offset;\n        segments.push(''); // push a placeholder (will be replaced)\n      },\n      onObjectProperty: function (name, offset, length) {\n        if (position < offset) {\n          throw earlyReturnException;\n        }\n\n        setPreviousNode(name, offset, length, 'property');\n        segments[segments.length - 1] = name;\n\n        if (position <= offset + length) {\n          throw earlyReturnException;\n        }\n      },\n      onObjectEnd: function (offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        previousNode = undefined;\n        segments.pop();\n      },\n      onArrayBegin: function (offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        previousNode = undefined;\n        segments.push(0);\n      },\n      onArrayEnd: function (offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        previousNode = undefined;\n        segments.pop();\n      },\n      onLiteralValue: function (value, offset, length) {\n        if (position < offset) {\n          throw earlyReturnException;\n        }\n\n        setPreviousNode(value, offset, length, getNodeType(value));\n\n        if (position <= offset + length) {\n          throw earlyReturnException;\n        }\n      },\n      onSeparator: function (sep, offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        if (sep === ':' && previousNode && previousNode.type === 'property') {\n          previousNode.colonOffset = offset;\n          isAtPropertyKey = false;\n          previousNode = undefined;\n        } else if (sep === ',') {\n          var last = segments[segments.length - 1];\n\n          if (typeof last === 'number') {\n            segments[segments.length - 1] = last + 1;\n          } else {\n            isAtPropertyKey = true;\n            segments[segments.length - 1] = '';\n          }\n\n          previousNode = undefined;\n        }\n      }\n    });\n  } catch (e) {\n    if (e !== earlyReturnException) {\n      throw e;\n    }\n  }\n\n  return {\n    path: segments,\n    previousNode: previousNode,\n    isAtPropertyKey: isAtPropertyKey,\n    matches: function (pattern) {\n      var k = 0;\n\n      for (var i = 0; k < pattern.length && i < segments.length; i++) {\n        if (pattern[k] === segments[i] || pattern[k] === '*') {\n          k++;\n        } else if (pattern[k] !== '**') {\n          return false;\n        }\n      }\n\n      return k === pattern.length;\n    }\n  };\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\n\nexport function parse(text, errors, options) {\n  if (errors === void 0) {\n    errors = [];\n  }\n\n  if (options === void 0) {\n    options = ParseOptions.DEFAULT;\n  }\n\n  var currentProperty = null;\n  var currentParent = [];\n  var previousParents = [];\n\n  function onValue(value) {\n    if (Array.isArray(currentParent)) {\n      currentParent.push(value);\n    } else if (currentProperty !== null) {\n      currentParent[currentProperty] = value;\n    }\n  }\n\n  var visitor = {\n    onObjectBegin: function () {\n      var object = {};\n      onValue(object);\n      previousParents.push(currentParent);\n      currentParent = object;\n      currentProperty = null;\n    },\n    onObjectProperty: function (name) {\n      currentProperty = name;\n    },\n    onObjectEnd: function () {\n      currentParent = previousParents.pop();\n    },\n    onArrayBegin: function () {\n      var array = [];\n      onValue(array);\n      previousParents.push(currentParent);\n      currentParent = array;\n      currentProperty = null;\n    },\n    onArrayEnd: function () {\n      currentParent = previousParents.pop();\n    },\n    onLiteralValue: onValue,\n    onError: function (error, offset, length) {\n      errors.push({\n        error: error,\n        offset: offset,\n        length: length\n      });\n    }\n  };\n  visit(text, visitor, options);\n  return currentParent[0];\n}\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\n\nexport function parseTree(text, errors, options) {\n  if (errors === void 0) {\n    errors = [];\n  }\n\n  if (options === void 0) {\n    options = ParseOptions.DEFAULT;\n  }\n\n  var currentParent = {\n    type: 'array',\n    offset: -1,\n    length: -1,\n    children: [],\n    parent: undefined\n  }; // artificial root\n\n  function ensurePropertyComplete(endOffset) {\n    if (currentParent.type === 'property') {\n      currentParent.length = endOffset - currentParent.offset;\n      currentParent = currentParent.parent;\n    }\n  }\n\n  function onValue(valueNode) {\n    currentParent.children.push(valueNode);\n    return valueNode;\n  }\n\n  var visitor = {\n    onObjectBegin: function (offset) {\n      currentParent = onValue({\n        type: 'object',\n        offset: offset,\n        length: -1,\n        parent: currentParent,\n        children: []\n      });\n    },\n    onObjectProperty: function (name, offset, length) {\n      currentParent = onValue({\n        type: 'property',\n        offset: offset,\n        length: -1,\n        parent: currentParent,\n        children: []\n      });\n      currentParent.children.push({\n        type: 'string',\n        value: name,\n        offset: offset,\n        length: length,\n        parent: currentParent\n      });\n    },\n    onObjectEnd: function (offset, length) {\n      ensurePropertyComplete(offset + length); // in case of a missing value for a property: make sure property is complete\n\n      currentParent.length = offset + length - currentParent.offset;\n      currentParent = currentParent.parent;\n      ensurePropertyComplete(offset + length);\n    },\n    onArrayBegin: function (offset, length) {\n      currentParent = onValue({\n        type: 'array',\n        offset: offset,\n        length: -1,\n        parent: currentParent,\n        children: []\n      });\n    },\n    onArrayEnd: function (offset, length) {\n      currentParent.length = offset + length - currentParent.offset;\n      currentParent = currentParent.parent;\n      ensurePropertyComplete(offset + length);\n    },\n    onLiteralValue: function (value, offset, length) {\n      onValue({\n        type: getNodeType(value),\n        offset: offset,\n        length: length,\n        parent: currentParent,\n        value: value\n      });\n      ensurePropertyComplete(offset + length);\n    },\n    onSeparator: function (sep, offset, length) {\n      if (currentParent.type === 'property') {\n        if (sep === ':') {\n          currentParent.colonOffset = offset;\n        } else if (sep === ',') {\n          ensurePropertyComplete(offset);\n        }\n      }\n    },\n    onError: function (error, offset, length) {\n      errors.push({\n        error: error,\n        offset: offset,\n        length: length\n      });\n    }\n  };\n  visit(text, visitor, options);\n  var result = currentParent.children[0];\n\n  if (result) {\n    delete result.parent;\n  }\n\n  return result;\n}\n/**\n * Finds the node at the given path in a JSON DOM.\n */\n\nexport function findNodeAtLocation(root, path) {\n  if (!root) {\n    return undefined;\n  }\n\n  var node = root;\n\n  for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n    var segment = path_1[_i];\n\n    if (typeof segment === 'string') {\n      if (node.type !== 'object' || !Array.isArray(node.children)) {\n        return undefined;\n      }\n\n      var found = false;\n\n      for (var _a = 0, _b = node.children; _a < _b.length; _a++) {\n        var propertyNode = _b[_a];\n\n        if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment && propertyNode.children.length === 2) {\n          node = propertyNode.children[1];\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        return undefined;\n      }\n    } else {\n      var index = segment;\n\n      if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n        return undefined;\n      }\n\n      node = node.children[index];\n    }\n  }\n\n  return node;\n}\n/**\n * Gets the JSON path of the given JSON DOM node\n */\n\nexport function getNodePath(node) {\n  if (!node.parent || !node.parent.children) {\n    return [];\n  }\n\n  var path = getNodePath(node.parent);\n\n  if (node.parent.type === 'property') {\n    var key = node.parent.children[0].value;\n    path.push(key);\n  } else if (node.parent.type === 'array') {\n    var index = node.parent.children.indexOf(node);\n\n    if (index !== -1) {\n      path.push(index);\n    }\n  }\n\n  return path;\n}\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\n\nexport function getNodeValue(node) {\n  switch (node.type) {\n    case 'array':\n      return node.children.map(getNodeValue);\n\n    case 'object':\n      var obj = Object.create(null);\n\n      for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n        var prop = _a[_i];\n        var valueNode = prop.children[1];\n\n        if (valueNode) {\n          obj[prop.children[0].value] = getNodeValue(valueNode);\n        }\n      }\n\n      return obj;\n\n    case 'null':\n    case 'string':\n    case 'number':\n    case 'boolean':\n      return node.value;\n\n    default:\n      return undefined;\n  }\n}\nexport function contains(node, offset, includeRightBound) {\n  if (includeRightBound === void 0) {\n    includeRightBound = false;\n  }\n\n  return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;\n}\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\n\nexport function findNodeAtOffset(node, offset, includeRightBound) {\n  if (includeRightBound === void 0) {\n    includeRightBound = false;\n  }\n\n  if (contains(node, offset, includeRightBound)) {\n    var children = node.children;\n\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length && children[i].offset <= offset; i++) {\n        var item = findNodeAtOffset(children[i], offset, includeRightBound);\n\n        if (item) {\n          return item;\n        }\n      }\n    }\n\n    return node;\n  }\n\n  return undefined;\n}\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\n\nexport function visit(text, visitor, options) {\n  if (options === void 0) {\n    options = ParseOptions.DEFAULT;\n  }\n\n  var _scanner = createScanner(text, false); // Important: Only pass copies of this to visitor functions to prevent accidental modification, and\n  // to not affect visitor functions which stored a reference to a previous JSONPath\n\n\n  var _jsonPath = [];\n\n  function toNoArgVisit(visitFunction) {\n    return visitFunction ? function () {\n      return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());\n    } : function () {\n      return true;\n    };\n  }\n\n  function toNoArgVisitWithPath(visitFunction) {\n    return visitFunction ? function () {\n      return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), function () {\n        return _jsonPath.slice();\n      });\n    } : function () {\n      return true;\n    };\n  }\n\n  function toOneArgVisit(visitFunction) {\n    return visitFunction ? function (arg) {\n      return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());\n    } : function () {\n      return true;\n    };\n  }\n\n  function toOneArgVisitWithPath(visitFunction) {\n    return visitFunction ? function (arg) {\n      return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), function () {\n        return _jsonPath.slice();\n      });\n    } : function () {\n      return true;\n    };\n  }\n\n  var onObjectBegin = toNoArgVisitWithPath(visitor.onObjectBegin),\n      onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty),\n      onObjectEnd = toNoArgVisit(visitor.onObjectEnd),\n      onArrayBegin = toNoArgVisitWithPath(visitor.onArrayBegin),\n      onArrayEnd = toNoArgVisit(visitor.onArrayEnd),\n      onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue),\n      onSeparator = toOneArgVisit(visitor.onSeparator),\n      onComment = toNoArgVisit(visitor.onComment),\n      onError = toOneArgVisit(visitor.onError);\n  var disallowComments = options && options.disallowComments;\n  var allowTrailingComma = options && options.allowTrailingComma;\n\n  function scanNext() {\n    while (true) {\n      var token = _scanner.scan();\n\n      switch (_scanner.getTokenError()) {\n        case 4\n        /* ScanError.InvalidUnicode */\n        :\n          handleError(14\n          /* ParseErrorCode.InvalidUnicode */\n          );\n          break;\n\n        case 5\n        /* ScanError.InvalidEscapeCharacter */\n        :\n          handleError(15\n          /* ParseErrorCode.InvalidEscapeCharacter */\n          );\n          break;\n\n        case 3\n        /* ScanError.UnexpectedEndOfNumber */\n        :\n          handleError(13\n          /* ParseErrorCode.UnexpectedEndOfNumber */\n          );\n          break;\n\n        case 1\n        /* ScanError.UnexpectedEndOfComment */\n        :\n          if (!disallowComments) {\n            handleError(11\n            /* ParseErrorCode.UnexpectedEndOfComment */\n            );\n          }\n\n          break;\n\n        case 2\n        /* ScanError.UnexpectedEndOfString */\n        :\n          handleError(12\n          /* ParseErrorCode.UnexpectedEndOfString */\n          );\n          break;\n\n        case 6\n        /* ScanError.InvalidCharacter */\n        :\n          handleError(16\n          /* ParseErrorCode.InvalidCharacter */\n          );\n          break;\n      }\n\n      switch (token) {\n        case 12\n        /* SyntaxKind.LineCommentTrivia */\n        :\n        case 13\n        /* SyntaxKind.BlockCommentTrivia */\n        :\n          if (disallowComments) {\n            handleError(10\n            /* ParseErrorCode.InvalidCommentToken */\n            );\n          } else {\n            onComment();\n          }\n\n          break;\n\n        case 16\n        /* SyntaxKind.Unknown */\n        :\n          handleError(1\n          /* ParseErrorCode.InvalidSymbol */\n          );\n          break;\n\n        case 15\n        /* SyntaxKind.Trivia */\n        :\n        case 14\n        /* SyntaxKind.LineBreakTrivia */\n        :\n          break;\n\n        default:\n          return token;\n      }\n    }\n  }\n\n  function handleError(error, skipUntilAfter, skipUntil) {\n    if (skipUntilAfter === void 0) {\n      skipUntilAfter = [];\n    }\n\n    if (skipUntil === void 0) {\n      skipUntil = [];\n    }\n\n    onError(error);\n\n    if (skipUntilAfter.length + skipUntil.length > 0) {\n      var token = _scanner.getToken();\n\n      while (token !== 17\n      /* SyntaxKind.EOF */\n      ) {\n        if (skipUntilAfter.indexOf(token) !== -1) {\n          scanNext();\n          break;\n        } else if (skipUntil.indexOf(token) !== -1) {\n          break;\n        }\n\n        token = scanNext();\n      }\n    }\n  }\n\n  function parseString(isValue) {\n    var value = _scanner.getTokenValue();\n\n    if (isValue) {\n      onLiteralValue(value);\n    } else {\n      onObjectProperty(value); // add property name afterwards\n\n      _jsonPath.push(value);\n    }\n\n    scanNext();\n    return true;\n  }\n\n  function parseLiteral() {\n    switch (_scanner.getToken()) {\n      case 11\n      /* SyntaxKind.NumericLiteral */\n      :\n        var tokenValue = _scanner.getTokenValue();\n\n        var value = Number(tokenValue);\n\n        if (isNaN(value)) {\n          handleError(2\n          /* ParseErrorCode.InvalidNumberFormat */\n          );\n          value = 0;\n        }\n\n        onLiteralValue(value);\n        break;\n\n      case 7\n      /* SyntaxKind.NullKeyword */\n      :\n        onLiteralValue(null);\n        break;\n\n      case 8\n      /* SyntaxKind.TrueKeyword */\n      :\n        onLiteralValue(true);\n        break;\n\n      case 9\n      /* SyntaxKind.FalseKeyword */\n      :\n        onLiteralValue(false);\n        break;\n\n      default:\n        return false;\n    }\n\n    scanNext();\n    return true;\n  }\n\n  function parseProperty() {\n    if (_scanner.getToken() !== 10\n    /* SyntaxKind.StringLiteral */\n    ) {\n      handleError(3\n      /* ParseErrorCode.PropertyNameExpected */\n      , [], [2\n      /* SyntaxKind.CloseBraceToken */\n      , 5\n      /* SyntaxKind.CommaToken */\n      ]);\n      return false;\n    }\n\n    parseString(false);\n\n    if (_scanner.getToken() === 6\n    /* SyntaxKind.ColonToken */\n    ) {\n      onSeparator(':');\n      scanNext(); // consume colon\n\n      if (!parseValue()) {\n        handleError(4\n        /* ParseErrorCode.ValueExpected */\n        , [], [2\n        /* SyntaxKind.CloseBraceToken */\n        , 5\n        /* SyntaxKind.CommaToken */\n        ]);\n      }\n    } else {\n      handleError(5\n      /* ParseErrorCode.ColonExpected */\n      , [], [2\n      /* SyntaxKind.CloseBraceToken */\n      , 5\n      /* SyntaxKind.CommaToken */\n      ]);\n    }\n\n    _jsonPath.pop(); // remove processed property name\n\n\n    return true;\n  }\n\n  function parseObject() {\n    onObjectBegin();\n    scanNext(); // consume open brace\n\n    var needsComma = false;\n\n    while (_scanner.getToken() !== 2\n    /* SyntaxKind.CloseBraceToken */\n    && _scanner.getToken() !== 17\n    /* SyntaxKind.EOF */\n    ) {\n      if (_scanner.getToken() === 5\n      /* SyntaxKind.CommaToken */\n      ) {\n        if (!needsComma) {\n          handleError(4\n          /* ParseErrorCode.ValueExpected */\n          , [], []);\n        }\n\n        onSeparator(',');\n        scanNext(); // consume comma\n\n        if (_scanner.getToken() === 2\n        /* SyntaxKind.CloseBraceToken */\n        && allowTrailingComma) {\n          break;\n        }\n      } else if (needsComma) {\n        handleError(6\n        /* ParseErrorCode.CommaExpected */\n        , [], []);\n      }\n\n      if (!parseProperty()) {\n        handleError(4\n        /* ParseErrorCode.ValueExpected */\n        , [], [2\n        /* SyntaxKind.CloseBraceToken */\n        , 5\n        /* SyntaxKind.CommaToken */\n        ]);\n      }\n\n      needsComma = true;\n    }\n\n    onObjectEnd();\n\n    if (_scanner.getToken() !== 2\n    /* SyntaxKind.CloseBraceToken */\n    ) {\n      handleError(7\n      /* ParseErrorCode.CloseBraceExpected */\n      , [2\n      /* SyntaxKind.CloseBraceToken */\n      ], []);\n    } else {\n      scanNext(); // consume close brace\n    }\n\n    return true;\n  }\n\n  function parseArray() {\n    onArrayBegin();\n    scanNext(); // consume open bracket\n\n    var isFirstElement = true;\n    var needsComma = false;\n\n    while (_scanner.getToken() !== 4\n    /* SyntaxKind.CloseBracketToken */\n    && _scanner.getToken() !== 17\n    /* SyntaxKind.EOF */\n    ) {\n      if (_scanner.getToken() === 5\n      /* SyntaxKind.CommaToken */\n      ) {\n        if (!needsComma) {\n          handleError(4\n          /* ParseErrorCode.ValueExpected */\n          , [], []);\n        }\n\n        onSeparator(',');\n        scanNext(); // consume comma\n\n        if (_scanner.getToken() === 4\n        /* SyntaxKind.CloseBracketToken */\n        && allowTrailingComma) {\n          break;\n        }\n      } else if (needsComma) {\n        handleError(6\n        /* ParseErrorCode.CommaExpected */\n        , [], []);\n      }\n\n      if (isFirstElement) {\n        _jsonPath.push(0);\n\n        isFirstElement = false;\n      } else {\n        _jsonPath[_jsonPath.length - 1]++;\n      }\n\n      if (!parseValue()) {\n        handleError(4\n        /* ParseErrorCode.ValueExpected */\n        , [], [4\n        /* SyntaxKind.CloseBracketToken */\n        , 5\n        /* SyntaxKind.CommaToken */\n        ]);\n      }\n\n      needsComma = true;\n    }\n\n    onArrayEnd();\n\n    if (!isFirstElement) {\n      _jsonPath.pop(); // remove array index\n\n    }\n\n    if (_scanner.getToken() !== 4\n    /* SyntaxKind.CloseBracketToken */\n    ) {\n      handleError(8\n      /* ParseErrorCode.CloseBracketExpected */\n      , [4\n      /* SyntaxKind.CloseBracketToken */\n      ], []);\n    } else {\n      scanNext(); // consume close bracket\n    }\n\n    return true;\n  }\n\n  function parseValue() {\n    switch (_scanner.getToken()) {\n      case 3\n      /* SyntaxKind.OpenBracketToken */\n      :\n        return parseArray();\n\n      case 1\n      /* SyntaxKind.OpenBraceToken */\n      :\n        return parseObject();\n\n      case 10\n      /* SyntaxKind.StringLiteral */\n      :\n        return parseString(true);\n\n      default:\n        return parseLiteral();\n    }\n  }\n\n  scanNext();\n\n  if (_scanner.getToken() === 17\n  /* SyntaxKind.EOF */\n  ) {\n    if (options.allowEmptyContent) {\n      return true;\n    }\n\n    handleError(4\n    /* ParseErrorCode.ValueExpected */\n    , [], []);\n    return false;\n  }\n\n  if (!parseValue()) {\n    handleError(4\n    /* ParseErrorCode.ValueExpected */\n    , [], []);\n    return false;\n  }\n\n  if (_scanner.getToken() !== 17\n  /* SyntaxKind.EOF */\n  ) {\n    handleError(9\n    /* ParseErrorCode.EndOfFileExpected */\n    , [], []);\n  }\n\n  return true;\n}\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\n\nexport function stripComments(text, replaceCh) {\n  var _scanner = createScanner(text),\n      parts = [],\n      kind,\n      offset = 0,\n      pos;\n\n  do {\n    pos = _scanner.getPosition();\n    kind = _scanner.scan();\n\n    switch (kind) {\n      case 12\n      /* SyntaxKind.LineCommentTrivia */\n      :\n      case 13\n      /* SyntaxKind.BlockCommentTrivia */\n      :\n      case 17\n      /* SyntaxKind.EOF */\n      :\n        if (offset !== pos) {\n          parts.push(text.substring(offset, pos));\n        }\n\n        if (replaceCh !== undefined) {\n          parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n        }\n\n        offset = _scanner.getPosition();\n        break;\n    }\n  } while (kind !== 17\n  /* SyntaxKind.EOF */\n  );\n\n  return parts.join('');\n}\nexport function getNodeType(value) {\n  switch (typeof value) {\n    case 'boolean':\n      return 'boolean';\n\n    case 'number':\n      return 'number';\n\n    case 'string':\n      return 'string';\n\n    case 'object':\n      {\n        if (!value) {\n          return 'null';\n        } else if (Array.isArray(value)) {\n          return 'array';\n        }\n\n        return 'object';\n      }\n\n    default:\n      return 'null';\n  }\n}","map":{"version":3,"names":["createScanner","ParseOptions","DEFAULT","allowTrailingComma","getLocation","text","position","segments","earlyReturnException","Object","previousNode","undefined","previousNodeInst","value","offset","length","type","parent","isAtPropertyKey","setPreviousNode","colonOffset","visit","onObjectBegin","push","onObjectProperty","name","onObjectEnd","pop","onArrayBegin","onArrayEnd","onLiteralValue","getNodeType","onSeparator","sep","last","e","path","matches","pattern","k","i","parse","errors","options","currentProperty","currentParent","previousParents","onValue","Array","isArray","visitor","object","array","onError","error","parseTree","children","ensurePropertyComplete","endOffset","valueNode","result","findNodeAtLocation","root","node","_i","path_1","segment","found","_a","_b","propertyNode","index","getNodePath","key","indexOf","getNodeValue","map","obj","create","prop","contains","includeRightBound","findNodeAtOffset","item","_scanner","_jsonPath","toNoArgVisit","visitFunction","getTokenOffset","getTokenLength","getTokenStartLine","getTokenStartCharacter","toNoArgVisitWithPath","slice","toOneArgVisit","arg","toOneArgVisitWithPath","onComment","disallowComments","scanNext","token","scan","getTokenError","handleError","skipUntilAfter","skipUntil","getToken","parseString","isValue","getTokenValue","parseLiteral","tokenValue","Number","isNaN","parseProperty","parseValue","parseObject","needsComma","parseArray","isFirstElement","allowEmptyContent","stripComments","replaceCh","parts","kind","pos","getPosition","substring","replace","join"],"sources":["/Users/braxtoncoats/Github/bcd/node_modules/jsonc-parser/lib/esm/impl/parser.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { createScanner } from './scanner';\nvar ParseOptions;\n(function (ParseOptions) {\n    ParseOptions.DEFAULT = {\n        allowTrailingComma: false\n    };\n})(ParseOptions || (ParseOptions = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport function getLocation(text, position) {\n    var segments = []; // strings or numbers\n    var earlyReturnException = new Object();\n    var previousNode = undefined;\n    var previousNodeInst = {\n        value: {},\n        offset: 0,\n        length: 0,\n        type: 'object',\n        parent: undefined\n    };\n    var isAtPropertyKey = false;\n    function setPreviousNode(value, offset, length, type) {\n        previousNodeInst.value = value;\n        previousNodeInst.offset = offset;\n        previousNodeInst.length = length;\n        previousNodeInst.type = type;\n        previousNodeInst.colonOffset = undefined;\n        previousNode = previousNodeInst;\n    }\n    try {\n        visit(text, {\n            onObjectBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                isAtPropertyKey = position > offset;\n                segments.push(''); // push a placeholder (will be replaced)\n            },\n            onObjectProperty: function (name, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(name, offset, length, 'property');\n                segments[segments.length - 1] = name;\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onObjectEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onArrayBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.push(0);\n            },\n            onArrayEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onLiteralValue: function (value, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(value, offset, length, getNodeType(value));\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onSeparator: function (sep, offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                if (sep === ':' && previousNode && previousNode.type === 'property') {\n                    previousNode.colonOffset = offset;\n                    isAtPropertyKey = false;\n                    previousNode = undefined;\n                }\n                else if (sep === ',') {\n                    var last = segments[segments.length - 1];\n                    if (typeof last === 'number') {\n                        segments[segments.length - 1] = last + 1;\n                    }\n                    else {\n                        isAtPropertyKey = true;\n                        segments[segments.length - 1] = '';\n                    }\n                    previousNode = undefined;\n                }\n            }\n        });\n    }\n    catch (e) {\n        if (e !== earlyReturnException) {\n            throw e;\n        }\n    }\n    return {\n        path: segments,\n        previousNode: previousNode,\n        isAtPropertyKey: isAtPropertyKey,\n        matches: function (pattern) {\n            var k = 0;\n            for (var i = 0; k < pattern.length && i < segments.length; i++) {\n                if (pattern[k] === segments[i] || pattern[k] === '*') {\n                    k++;\n                }\n                else if (pattern[k] !== '**') {\n                    return false;\n                }\n            }\n            return k === pattern.length;\n        }\n    };\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport function parse(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var currentProperty = null;\n    var currentParent = [];\n    var previousParents = [];\n    function onValue(value) {\n        if (Array.isArray(currentParent)) {\n            currentParent.push(value);\n        }\n        else if (currentProperty !== null) {\n            currentParent[currentProperty] = value;\n        }\n    }\n    var visitor = {\n        onObjectBegin: function () {\n            var object = {};\n            onValue(object);\n            previousParents.push(currentParent);\n            currentParent = object;\n            currentProperty = null;\n        },\n        onObjectProperty: function (name) {\n            currentProperty = name;\n        },\n        onObjectEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onArrayBegin: function () {\n            var array = [];\n            onValue(array);\n            previousParents.push(currentParent);\n            currentParent = array;\n            currentProperty = null;\n        },\n        onArrayEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onLiteralValue: onValue,\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    return currentParent[0];\n}\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport function parseTree(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root\n    function ensurePropertyComplete(endOffset) {\n        if (currentParent.type === 'property') {\n            currentParent.length = endOffset - currentParent.offset;\n            currentParent = currentParent.parent;\n        }\n    }\n    function onValue(valueNode) {\n        currentParent.children.push(valueNode);\n        return valueNode;\n    }\n    var visitor = {\n        onObjectBegin: function (offset) {\n            currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onObjectProperty: function (name, offset, length) {\n            currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });\n            currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });\n        },\n        onObjectEnd: function (offset, length) {\n            ensurePropertyComplete(offset + length); // in case of a missing value for a property: make sure property is complete\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onArrayBegin: function (offset, length) {\n            currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onArrayEnd: function (offset, length) {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onLiteralValue: function (value, offset, length) {\n            onValue({ type: getNodeType(value), offset: offset, length: length, parent: currentParent, value: value });\n            ensurePropertyComplete(offset + length);\n        },\n        onSeparator: function (sep, offset, length) {\n            if (currentParent.type === 'property') {\n                if (sep === ':') {\n                    currentParent.colonOffset = offset;\n                }\n                else if (sep === ',') {\n                    ensurePropertyComplete(offset);\n                }\n            }\n        },\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    var result = currentParent.children[0];\n    if (result) {\n        delete result.parent;\n    }\n    return result;\n}\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport function findNodeAtLocation(root, path) {\n    if (!root) {\n        return undefined;\n    }\n    var node = root;\n    for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n        var segment = path_1[_i];\n        if (typeof segment === 'string') {\n            if (node.type !== 'object' || !Array.isArray(node.children)) {\n                return undefined;\n            }\n            var found = false;\n            for (var _a = 0, _b = node.children; _a < _b.length; _a++) {\n                var propertyNode = _b[_a];\n                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment && propertyNode.children.length === 2) {\n                    node = propertyNode.children[1];\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return undefined;\n            }\n        }\n        else {\n            var index = segment;\n            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n                return undefined;\n            }\n            node = node.children[index];\n        }\n    }\n    return node;\n}\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport function getNodePath(node) {\n    if (!node.parent || !node.parent.children) {\n        return [];\n    }\n    var path = getNodePath(node.parent);\n    if (node.parent.type === 'property') {\n        var key = node.parent.children[0].value;\n        path.push(key);\n    }\n    else if (node.parent.type === 'array') {\n        var index = node.parent.children.indexOf(node);\n        if (index !== -1) {\n            path.push(index);\n        }\n    }\n    return path;\n}\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport function getNodeValue(node) {\n    switch (node.type) {\n        case 'array':\n            return node.children.map(getNodeValue);\n        case 'object':\n            var obj = Object.create(null);\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                var prop = _a[_i];\n                var valueNode = prop.children[1];\n                if (valueNode) {\n                    obj[prop.children[0].value] = getNodeValue(valueNode);\n                }\n            }\n            return obj;\n        case 'null':\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return node.value;\n        default:\n            return undefined;\n    }\n}\nexport function contains(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));\n}\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport function findNodeAtOffset(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    if (contains(node, offset, includeRightBound)) {\n        var children = node.children;\n        if (Array.isArray(children)) {\n            for (var i = 0; i < children.length && children[i].offset <= offset; i++) {\n                var item = findNodeAtOffset(children[i], offset, includeRightBound);\n                if (item) {\n                    return item;\n                }\n            }\n        }\n        return node;\n    }\n    return undefined;\n}\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport function visit(text, visitor, options) {\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var _scanner = createScanner(text, false);\n    // Important: Only pass copies of this to visitor functions to prevent accidental modification, and\n    // to not affect visitor functions which stored a reference to a previous JSONPath\n    var _jsonPath = [];\n    function toNoArgVisit(visitFunction) {\n        return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };\n    }\n    function toNoArgVisitWithPath(visitFunction) {\n        return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), function () { return _jsonPath.slice(); }); } : function () { return true; };\n    }\n    function toOneArgVisit(visitFunction) {\n        return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };\n    }\n    function toOneArgVisitWithPath(visitFunction) {\n        return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), function () { return _jsonPath.slice(); }); } : function () { return true; };\n    }\n    var onObjectBegin = toNoArgVisitWithPath(visitor.onObjectBegin), onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisitWithPath(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);\n    var disallowComments = options && options.disallowComments;\n    var allowTrailingComma = options && options.allowTrailingComma;\n    function scanNext() {\n        while (true) {\n            var token = _scanner.scan();\n            switch (_scanner.getTokenError()) {\n                case 4 /* ScanError.InvalidUnicode */:\n                    handleError(14 /* ParseErrorCode.InvalidUnicode */);\n                    break;\n                case 5 /* ScanError.InvalidEscapeCharacter */:\n                    handleError(15 /* ParseErrorCode.InvalidEscapeCharacter */);\n                    break;\n                case 3 /* ScanError.UnexpectedEndOfNumber */:\n                    handleError(13 /* ParseErrorCode.UnexpectedEndOfNumber */);\n                    break;\n                case 1 /* ScanError.UnexpectedEndOfComment */:\n                    if (!disallowComments) {\n                        handleError(11 /* ParseErrorCode.UnexpectedEndOfComment */);\n                    }\n                    break;\n                case 2 /* ScanError.UnexpectedEndOfString */:\n                    handleError(12 /* ParseErrorCode.UnexpectedEndOfString */);\n                    break;\n                case 6 /* ScanError.InvalidCharacter */:\n                    handleError(16 /* ParseErrorCode.InvalidCharacter */);\n                    break;\n            }\n            switch (token) {\n                case 12 /* SyntaxKind.LineCommentTrivia */:\n                case 13 /* SyntaxKind.BlockCommentTrivia */:\n                    if (disallowComments) {\n                        handleError(10 /* ParseErrorCode.InvalidCommentToken */);\n                    }\n                    else {\n                        onComment();\n                    }\n                    break;\n                case 16 /* SyntaxKind.Unknown */:\n                    handleError(1 /* ParseErrorCode.InvalidSymbol */);\n                    break;\n                case 15 /* SyntaxKind.Trivia */:\n                case 14 /* SyntaxKind.LineBreakTrivia */:\n                    break;\n                default:\n                    return token;\n            }\n        }\n    }\n    function handleError(error, skipUntilAfter, skipUntil) {\n        if (skipUntilAfter === void 0) { skipUntilAfter = []; }\n        if (skipUntil === void 0) { skipUntil = []; }\n        onError(error);\n        if (skipUntilAfter.length + skipUntil.length > 0) {\n            var token = _scanner.getToken();\n            while (token !== 17 /* SyntaxKind.EOF */) {\n                if (skipUntilAfter.indexOf(token) !== -1) {\n                    scanNext();\n                    break;\n                }\n                else if (skipUntil.indexOf(token) !== -1) {\n                    break;\n                }\n                token = scanNext();\n            }\n        }\n    }\n    function parseString(isValue) {\n        var value = _scanner.getTokenValue();\n        if (isValue) {\n            onLiteralValue(value);\n        }\n        else {\n            onObjectProperty(value);\n            // add property name afterwards\n            _jsonPath.push(value);\n        }\n        scanNext();\n        return true;\n    }\n    function parseLiteral() {\n        switch (_scanner.getToken()) {\n            case 11 /* SyntaxKind.NumericLiteral */:\n                var tokenValue = _scanner.getTokenValue();\n                var value = Number(tokenValue);\n                if (isNaN(value)) {\n                    handleError(2 /* ParseErrorCode.InvalidNumberFormat */);\n                    value = 0;\n                }\n                onLiteralValue(value);\n                break;\n            case 7 /* SyntaxKind.NullKeyword */:\n                onLiteralValue(null);\n                break;\n            case 8 /* SyntaxKind.TrueKeyword */:\n                onLiteralValue(true);\n                break;\n            case 9 /* SyntaxKind.FalseKeyword */:\n                onLiteralValue(false);\n                break;\n            default:\n                return false;\n        }\n        scanNext();\n        return true;\n    }\n    function parseProperty() {\n        if (_scanner.getToken() !== 10 /* SyntaxKind.StringLiteral */) {\n            handleError(3 /* ParseErrorCode.PropertyNameExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n            return false;\n        }\n        parseString(false);\n        if (_scanner.getToken() === 6 /* SyntaxKind.ColonToken */) {\n            onSeparator(':');\n            scanNext(); // consume colon\n            if (!parseValue()) {\n                handleError(4 /* ParseErrorCode.ValueExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n            }\n        }\n        else {\n            handleError(5 /* ParseErrorCode.ColonExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n        }\n        _jsonPath.pop(); // remove processed property name\n        return true;\n    }\n    function parseObject() {\n        onObjectBegin();\n        scanNext(); // consume open brace\n        var needsComma = false;\n        while (_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */ && _scanner.getToken() !== 17 /* SyntaxKind.EOF */) {\n            if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 2 /* SyntaxKind.CloseBraceToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* ParseErrorCode.CommaExpected */, [], []);\n            }\n            if (!parseProperty()) {\n                handleError(4 /* ParseErrorCode.ValueExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onObjectEnd();\n        if (_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */) {\n            handleError(7 /* ParseErrorCode.CloseBraceExpected */, [2 /* SyntaxKind.CloseBraceToken */], []);\n        }\n        else {\n            scanNext(); // consume close brace\n        }\n        return true;\n    }\n    function parseArray() {\n        onArrayBegin();\n        scanNext(); // consume open bracket\n        var isFirstElement = true;\n        var needsComma = false;\n        while (_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */ && _scanner.getToken() !== 17 /* SyntaxKind.EOF */) {\n            if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 4 /* SyntaxKind.CloseBracketToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* ParseErrorCode.CommaExpected */, [], []);\n            }\n            if (isFirstElement) {\n                _jsonPath.push(0);\n                isFirstElement = false;\n            }\n            else {\n                _jsonPath[_jsonPath.length - 1]++;\n            }\n            if (!parseValue()) {\n                handleError(4 /* ParseErrorCode.ValueExpected */, [], [4 /* SyntaxKind.CloseBracketToken */, 5 /* SyntaxKind.CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onArrayEnd();\n        if (!isFirstElement) {\n            _jsonPath.pop(); // remove array index\n        }\n        if (_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */) {\n            handleError(8 /* ParseErrorCode.CloseBracketExpected */, [4 /* SyntaxKind.CloseBracketToken */], []);\n        }\n        else {\n            scanNext(); // consume close bracket\n        }\n        return true;\n    }\n    function parseValue() {\n        switch (_scanner.getToken()) {\n            case 3 /* SyntaxKind.OpenBracketToken */:\n                return parseArray();\n            case 1 /* SyntaxKind.OpenBraceToken */:\n                return parseObject();\n            case 10 /* SyntaxKind.StringLiteral */:\n                return parseString(true);\n            default:\n                return parseLiteral();\n        }\n    }\n    scanNext();\n    if (_scanner.getToken() === 17 /* SyntaxKind.EOF */) {\n        if (options.allowEmptyContent) {\n            return true;\n        }\n        handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n        return false;\n    }\n    if (!parseValue()) {\n        handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n        return false;\n    }\n    if (_scanner.getToken() !== 17 /* SyntaxKind.EOF */) {\n        handleError(9 /* ParseErrorCode.EndOfFileExpected */, [], []);\n    }\n    return true;\n}\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport function stripComments(text, replaceCh) {\n    var _scanner = createScanner(text), parts = [], kind, offset = 0, pos;\n    do {\n        pos = _scanner.getPosition();\n        kind = _scanner.scan();\n        switch (kind) {\n            case 12 /* SyntaxKind.LineCommentTrivia */:\n            case 13 /* SyntaxKind.BlockCommentTrivia */:\n            case 17 /* SyntaxKind.EOF */:\n                if (offset !== pos) {\n                    parts.push(text.substring(offset, pos));\n                }\n                if (replaceCh !== undefined) {\n                    parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n                }\n                offset = _scanner.getPosition();\n                break;\n        }\n    } while (kind !== 17 /* SyntaxKind.EOF */);\n    return parts.join('');\n}\nexport function getNodeType(value) {\n    switch (typeof value) {\n        case 'boolean': return 'boolean';\n        case 'number': return 'number';\n        case 'string': return 'string';\n        case 'object': {\n            if (!value) {\n                return 'null';\n            }\n            else if (Array.isArray(value)) {\n                return 'array';\n            }\n            return 'object';\n        }\n        default: return 'null';\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}