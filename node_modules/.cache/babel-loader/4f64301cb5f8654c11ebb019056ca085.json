{"ast":null,"code":"/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nconst _ = require('../utils/es6_'),\n      usesReference = require('../utils/references/usesReference');\n/**\n * Applies all transforms to a property. This is a pure function,\n * it returns a new property object rather than mutating it inline.\n * @private\n * @param {Object} property\n * @param {Object} options\n * @returns {Object} - A new property object with transforms applied.\n */\n\n\nfunction transformProperty(property, options) {\n  const to_ret = _.clone(property);\n\n  const transforms = options.transforms;\n\n  for (let i = 0; i < transforms.length; i++) {\n    const transform = transforms[i];\n\n    if (!transform.matcher || transform.matcher(to_ret)) {\n      if (transform.type === 'name') to_ret.name = transform.transformer(to_ret, options); // Don't try to transform the value if it is referencing another value\n      // Only try to transform if the value is not a string or if it has '{}'\n\n      if (transform.type === 'value' && !usesReference(property.value, options)) {\n        // Only transform non-referenced values (from original)\n        // and transitive transforms if the value has been resolved\n        if (!usesReference(property.original.value, options) || transform.transitive) {\n          to_ret.value = transform.transformer(to_ret, options);\n        }\n      }\n\n      if (transform.type === 'attribute') to_ret.attributes = _.extend({}, to_ret.attributes, transform.transformer(to_ret, options));\n    }\n  }\n\n  return to_ret;\n}\n\nmodule.exports = transformProperty;","map":{"version":3,"names":["_","require","usesReference","transformProperty","property","options","to_ret","clone","transforms","i","length","transform","matcher","type","name","transformer","value","original","transitive","attributes","extend","module","exports"],"sources":["/Users/braxtoncoats/Github/bcd/node_modules/style-dictionary/lib/transform/property.js"],"sourcesContent":["/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\nconst _ = require('../utils/es6_'),\n  usesReference = require('../utils/references/usesReference');\n\n/**\n * Applies all transforms to a property. This is a pure function,\n * it returns a new property object rather than mutating it inline.\n * @private\n * @param {Object} property\n * @param {Object} options\n * @returns {Object} - A new property object with transforms applied.\n */\nfunction transformProperty(property, options) {\n  const to_ret = _.clone(property);\n  const transforms = options.transforms;\n\n  for (let i = 0; i < transforms.length; i++ ) {\n    const transform = transforms[i];\n\n    if (!transform.matcher || transform.matcher(to_ret)) {\n      if (transform.type === 'name')\n        to_ret.name = transform.transformer(to_ret, options);\n      // Don't try to transform the value if it is referencing another value\n      // Only try to transform if the value is not a string or if it has '{}'\n      if (transform.type === 'value' && !usesReference(property.value, options)) {\n        // Only transform non-referenced values (from original)\n        // and transitive transforms if the value has been resolved\n        if (!usesReference(property.original.value, options) || transform.transitive) {\n          to_ret.value = transform.transformer(to_ret, options);\n        }\n      }\n\n      if (transform.type === 'attribute')\n        to_ret.attributes = _.extend({}, to_ret.attributes, transform.transformer(to_ret, options));\n    }\n  }\n\n  return to_ret;\n}\n\n\nmodule.exports = transformProperty;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,CAAC,GAAGC,OAAO,CAAC,eAAD,CAAjB;AAAA,MACEC,aAAa,GAAGD,OAAO,CAAC,mCAAD,CADzB;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,iBAAT,CAA2BC,QAA3B,EAAqCC,OAArC,EAA8C;EAC5C,MAAMC,MAAM,GAAGN,CAAC,CAACO,KAAF,CAAQH,QAAR,CAAf;;EACA,MAAMI,UAAU,GAAGH,OAAO,CAACG,UAA3B;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,UAAU,CAACE,MAA/B,EAAuCD,CAAC,EAAxC,EAA6C;IAC3C,MAAME,SAAS,GAAGH,UAAU,CAACC,CAAD,CAA5B;;IAEA,IAAI,CAACE,SAAS,CAACC,OAAX,IAAsBD,SAAS,CAACC,OAAV,CAAkBN,MAAlB,CAA1B,EAAqD;MACnD,IAAIK,SAAS,CAACE,IAAV,KAAmB,MAAvB,EACEP,MAAM,CAACQ,IAAP,GAAcH,SAAS,CAACI,WAAV,CAAsBT,MAAtB,EAA8BD,OAA9B,CAAd,CAFiD,CAGnD;MACA;;MACA,IAAIM,SAAS,CAACE,IAAV,KAAmB,OAAnB,IAA8B,CAACX,aAAa,CAACE,QAAQ,CAACY,KAAV,EAAiBX,OAAjB,CAAhD,EAA2E;QACzE;QACA;QACA,IAAI,CAACH,aAAa,CAACE,QAAQ,CAACa,QAAT,CAAkBD,KAAnB,EAA0BX,OAA1B,CAAd,IAAoDM,SAAS,CAACO,UAAlE,EAA8E;UAC5EZ,MAAM,CAACU,KAAP,GAAeL,SAAS,CAACI,WAAV,CAAsBT,MAAtB,EAA8BD,OAA9B,CAAf;QACD;MACF;;MAED,IAAIM,SAAS,CAACE,IAAV,KAAmB,WAAvB,EACEP,MAAM,CAACa,UAAP,GAAoBnB,CAAC,CAACoB,MAAF,CAAS,EAAT,EAAad,MAAM,CAACa,UAApB,EAAgCR,SAAS,CAACI,WAAV,CAAsBT,MAAtB,EAA8BD,OAA9B,CAAhC,CAApB;IACH;EACF;;EAED,OAAOC,MAAP;AACD;;AAGDe,MAAM,CAACC,OAAP,GAAiBnB,iBAAjB"},"metadata":{},"sourceType":"script"}