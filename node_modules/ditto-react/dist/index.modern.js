import { jsx, Fragment as Fragment$1 } from 'react/jsx-runtime';
import React, { createContext, Fragment, useContext, useMemo } from 'react';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

const SourceDetector = {
  isFrame: function (source) {
    if (!source) {
      return false;
    }

    const value = source[Object.keys(source)[0]];
    return value !== null && typeof value === "object" && "frameName" in value;
  },
  isFlat: function (source) {
    if (!source) {
      return false;
    }

    const value = source[Object.keys(source)[0]];
    return typeof value === "string";
  },
  isStructured: function (source) {
    if (!source) {
      return false;
    }

    const value = source[Object.keys(source)[0]];
    return value !== null && typeof value === "object" && !this.isFrame(source);
  }
};
const DittoContext = createContext({});

const filterBlock = (blockObj, variables, count, filters) => {
  return Object.keys(blockObj).filter(textId => {
    if (!(filters != null && filters.tags)) return true;
    return filters.tags.every(tag => blockObj[textId].tags && blockObj[textId].tags.includes(tag));
  }).reduce((obj, id) => {
    const interpolatedText = interpolateVariableText(blockObj[id], variables, count).text;
    return _extends({}, obj, {
      [id]: interpolatedText
    });
  }, {});
};
const filterFrame = (_frameObj, variables, count, filters) => {
  const frameObj = JSON.parse(JSON.stringify(_frameObj));

  if (frameObj.blocks) {
    for (var blockId in frameObj.blocks) {
      frameObj.blocks[blockId] = filterBlock(frameObj.blocks[blockId], variables, count, filters);
    }
  }

  return _extends({}, frameObj, {
    otherText: filterBlock(frameObj.otherText, variables, count, filters)
  });
};
const error = (message, returnValue = message) => {
  console.error(message);
  return returnValue;
};
const nullError = message => error(message, null);
const fragmentError = message => error(message, jsx(Fragment, {}, void 0));
const isProject = (props, projectIdFromContext) => ("projectId" in props || !!projectIdFromContext) && ("textId" in props || "frameId" in props || "blockId" in props);
const isComponentLibrary = props => "componentId" in props;
const isText = props => "textId" in props;
const isFrameOrBlockComponent = props => "frameId" in props;
const useProjectId = props => {
  const dittoContext = useContext(DittoContext);
  const projectId = dittoContext.projectId || props.projectId;

  if (!projectId) {
    return fragmentError("No Project ID was provided to the <DittoProvider /> or <Ditto /> components.");
  }

  return projectId;
};
/**
 *
 * @param data
 * text data
 * @param count
 * the variable number used to determine which plural case to use
 * zero = 0
 * one = 1
 * two = 2
 * few = 3,4,5
 * many = 6,7,...,99
 * other = 100, 101, ...
 * if count is provided but not matching plural key, fallback to base plural value
 * in future we should also user's to define their own middleware for picking plurals
 * based off i8next: https://www.i18next.com/translation-function/plurals
 */

const getPluralText = (data, count) => {
  var _Object$keys;

  if (count === undefined || ((_Object$keys = Object.keys((data == null ? void 0 : data.plurals) || {})) == null ? void 0 : _Object$keys.length) === 0) {
    return data.text;
  } else if (count === 0 && data.plurals.zero) {
    return data.plurals.zero;
  } else if (count === 1 && data.plurals.one) {
    return data.plurals.one;
  } else if (count === 2 && data.plurals.two) {
    return data.plurals.two;
  } else if (count >= 3 && count <= 5 && data.plurals.few) {
    return data.plurals.few;
  } else if (count >= 6 && count <= 99 && data.plurals.many) {
    return data.plurals.many;
  } else {
    // default to 'other', fallback to base text
    if (data.plurals.other) return data.plurals.other;
    return data.text;
  }
};

const interpolateVariableText = (data, variables, count) => {
  const variablesWithFallbacks = Object.keys((data == null ? void 0 : data.variables) || {}).reduce((acc, curr) => {
    if (variables[curr]) {
      acc[curr] = variables[curr];
    } else {
      const {
        fallback,
        text
      } = data.variables[curr];
      acc[curr] = fallback || text;
    }

    return acc;
  }, {});
  const pluralText = getPluralText(data, count);
  return _extends({}, data, {
    text: generateVariableText(pluralText, variablesWithFallbacks)
  });
};
const HANDLEBAR_REGEX = /\{\{([a-z0-9_]+)\}\}/gi;
/**
 * Execute a callback for each valid variable found in
 * `text`. The callback is passed an object that includes:
 * - `name`: the name of the variable
 * - `start`: the index of opening curly brace of the variable in `text`
 * - `end`: the index of the closing curly brace of the variable in `text`
 */

const forEachVariable = (text, callback) => {
  let matches = null;

  while ((matches = HANDLEBAR_REGEX.exec(text)) !== null) {
    const [match] = matches;

    if (!match) {
      break;
    }

    const variableName = match.replace(/(\{\{|\}\})/g, "");
    callback({
      name: variableName,
      start: matches.index,
      end: matches.index + match.length - 1
    });
  }
};

const getVariable = (variableName, variables) => {
  const variable = variables[variableName];

  if (!variable) {
    return null;
  }

  return variable;
};

const getVariablePlaceholder = variable => {
  if (!(variable && variable.data)) {
    return null;
  }

  if (variable.data.fallback) {
    return String(variable.data.fallback);
  }

  if (variable.data.text) {
    return String(variable.data.text);
  }

  return null;
};

const generateVariableText = (text, variables) => {
  let lastIndex = 0;
  let updatedText = "";
  forEachVariable(text, ({
    name,
    start,
    end
  }) => {
    const variableValue = getVariable(name, variables) || getVariablePlaceholder(name);

    if (variableValue) {
      updatedText += text.substring(lastIndex, start) + variableValue;
    } else {
      updatedText += text.substr(lastIndex, end + 1);
    }

    lastIndex = end + 1;
  });
  const remainder = text.substr(lastIndex);

  if (remainder) {
    updatedText += remainder;
  }

  return updatedText;
};

const useDittoSingleText = props => {
  var _source$projectId2;

  const {
    projectId,
    textId,
    variables,
    count
  } = props;
  const {
    source,
    variant
  } = useContext(DittoContext);
  if (!projectId) return nullError("No Project ID provided.");

  if (variant) {
    var _source$projectId;

    const _data = source == null ? void 0 : (_source$projectId = source[projectId]) == null ? void 0 : _source$projectId[variant];

    if (_data) {
      if (SourceDetector.isStructured(_data)) {
        return interpolateVariableText(_data[textId], variables, count).text;
      }

      if (SourceDetector.isFlat(_data)) {
        return _data[textId];
      }

      if (SourceDetector.isFrame(_data)) {
        for (const frameId in _data) {
          const frame = _data[frameId];

          for (const blockId in frame.blocks) {
            const block = frame.blocks[blockId];
            if (textId in block) return interpolateVariableText(block[textId], variables, count).text;
          }

          if (frame.otherText && textId in frame.otherText) return interpolateVariableText(frame.otherText[textId], variables, count).text;
        }
      }
    }
  }

  const data = source == null ? void 0 : (_source$projectId2 = source[projectId]) == null ? void 0 : _source$projectId2.base;

  if (!data) {
    return nullError(`Project not found with id "${projectId}"`);
  }

  if (SourceDetector.isStructured(data)) {
    return interpolateVariableText(data[textId], variables, count).text;
  }

  if (SourceDetector.isFlat(data)) {
    return data[textId];
  }

  if (SourceDetector.isFrame(data)) {
    for (const frameId in data) {
      const frame = data[frameId];

      for (const blockId in frame.blocks) {
        const block = frame.blocks[blockId];
        if (textId in block) return interpolateVariableText(block[textId], variables, count).text;
      }

      if (frame.otherText && textId in frame.otherText) return interpolateVariableText(frame.otherText[textId], variables, count).text;
    }
  }

  return `Text not found for id "${textId}"`;
};

const DittoText = props => {
  const {
    textId,
    children,
    variables,
    count
  } = props;
  const projectId = useProjectId(props);
  const text = useDittoSingleText({
    projectId,
    textId,
    variables: variables || {},
    count
  });
  return jsx(React.Fragment, {
    children: typeof children === "function" ? children(text) : text
  }, void 0);
};

const useDitto = props => {
  var _source$projectId2;

  const {
    projectId,
    frameId,
    blockId,
    filters,
    variables,
    count
  } = props;
  const {
    source,
    variant
  } = useContext(DittoContext);
  if (!projectId) return nullError("No Project ID provided.");

  if (variant) {
    var _source$projectId;

    const _data = source == null ? void 0 : (_source$projectId = source[projectId]) == null ? void 0 : _source$projectId[variant];

    if (SourceDetector.isFrame(_data) && frameId) {
      const _frame = _data[frameId];

      if (_frame) {
        if (!blockId) {
          return filterFrame(_frame, variables || {}, count, filters);
        }

        if (blockId in _frame.blocks) {
          const _block = _frame.blocks[blockId];

          if (_block) {
            return filterBlock(_block, variables || {}, count, filters);
          }
        }
      }
    }
  }

  const data = (_source$projectId2 = source[projectId]) == null ? void 0 : _source$projectId2.base;

  if (!data) {
    return nullError(`Project not found with id "${projectId}"`);
  }

  if (!SourceDetector.isFrame(data)) {
    return nullError(`Default format must be used if passing "frameId" or "blockId"`);
  }

  if (!frameId) {
    return nullError("No Frame ID provided.");
  }

  const frame = data[frameId];
  if (!frame) return nullError(`Frame "${frameId}" not found this project "${projectId}"`);
  if (!blockId) return filterFrame(frame, variables || {}, count, filters);
  const block = frame.blocks[blockId];
  if (!block) return nullError(`Block "${blockId}" not found in frame "${frameId}" in project "${projectId}"`);
  return filterBlock(block, variables || {}, count, filters);
};

const _excluded = ["children"];
const DittoFrameOrBlock = props => {
  const {
    children
  } = props,
        otherProps = _objectWithoutPropertiesLoose(props, _excluded);

  const data = useDitto(otherProps);

  if (typeof children !== "function") {
    return fragmentError(`Please provide either a textId or function child to your Ditto component.`);
  }

  if (!data || typeof data !== "object") {
    return jsx(Fragment$1, {
      children: data
    }, void 0);
  }

  return jsx(Fragment$1, {
    children: children(data)
  }, void 0);
};
const DittoFrame = props => {
  const projectId = useProjectId(props);
  return jsx(DittoFrameOrBlock, Object.assign({}, props, {
    projectId: projectId
  }), void 0);
};
const DittoBlock = props => {
  const projectId = useProjectId(props);
  return jsx(DittoFrameOrBlock, Object.assign({}, props, {
    projectId: projectId
  }), void 0);
};

const useDittoComponent = props => {
  var _source$ditto_compone2;

  const {
    componentId,
    alwaysReturnString,
    variables,
    count
  } = props;
  const {
    source,
    variant
  } = useContext(DittoContext);

  if (!("ditto_component_library" in source)) {
    throw new Error("An export file for the Component Library couldn't be found.");
  }

  if (variant) {
    var _source$ditto_compone;

    const _data = source == null ? void 0 : (_source$ditto_compone = source.ditto_component_library) == null ? void 0 : _source$ditto_compone[variant];

    if (_data && _data[componentId]) {
      if (SourceDetector.isStructured(_data)) {
        const value = interpolateVariableText(_data[componentId], variables, count);
        return alwaysReturnString ? value.text : value;
      } else if (SourceDetector.isFlat(_data)) {
        return _data[componentId];
      }
    }
  }

  const data = source == null ? void 0 : (_source$ditto_compone2 = source.ditto_component_library) == null ? void 0 : _source$ditto_compone2.base;

  if (!data) {
    return nullError("Base text not found in component library");
  }

  if (data && !data[componentId]) {
    return nullError(`Text not found for component "${componentId}"`);
  }

  if (SourceDetector.isStructured(data)) {
    const value = interpolateVariableText(data[componentId], variables, count);
    return alwaysReturnString ? value.text : value;
  } else if (SourceDetector.isFlat(data)) {
    return data[componentId];
  } else {
    return nullError(`Invalid format for component ${componentId}`);
  }
};

const DittoComponent = props => {
  const {
    children,
    componentId,
    variables,
    count
  } = props;
  const value = useDittoComponent({
    componentId,
    alwaysReturnString: typeof children !== "function",
    variables: variables || {},
    count
  });
  const text = useMemo(() => value !== null && typeof value === "object" ? value.text : value, [value]);
  return jsx(React.Fragment, {
    children: typeof children === "function" ? children(text) : text
  }, void 0);
};

function Ditto(props) {
  const dittoContext = useContext(DittoContext);

  if (isComponentLibrary(props)) {
    return jsx(DittoComponent, Object.assign({}, props), void 0);
  }

  if (isProject(props, dittoContext.projectId)) {
    const projectId = props.projectId || dittoContext.projectId;

    if (!projectId) {
      return fragmentError("No Project ID was provided to the <DittoProvider /> or <Ditto /> components.");
    }

    const propsWithProject = _extends({}, props, {
      projectId
    });

    if (isText(propsWithProject)) {
      return jsx(DittoText, Object.assign({}, propsWithProject), void 0);
    }

    if (isFrameOrBlockComponent(propsWithProject)) {
      return jsx(DittoFrameOrBlock, Object.assign({}, propsWithProject), void 0);
    }
  }

  return fragmentError('Invalid props provided to Ditto component; please provide "componentId", "textId" or "frameId"');
}

const DittoProvider = props => {
  const {
    children,
    source,
    variant,
    projectId
  } = props;
  return jsx(DittoContext.Provider, Object.assign({
    value: _extends({
      source,
      variant
    }, projectId ? {
      projectId
    } : {})
  }, {
    children: children
  }), void 0);
};

export default DittoProvider;
export { Ditto, DittoBlock, DittoComponent, DittoFrame, DittoProvider, DittoText };
//# sourceMappingURL=index.modern.js.map
