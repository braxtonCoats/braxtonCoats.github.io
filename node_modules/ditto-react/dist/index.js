var jsxRuntime = require('react/jsx-runtime');
var React = require('react');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var SourceDetector = {
  isFrame: function isFrame(source) {
    if (!source) {
      return false;
    }

    var value = source[Object.keys(source)[0]];
    return value !== null && typeof value === "object" && "frameName" in value;
  },
  isFlat: function isFlat(source) {
    if (!source) {
      return false;
    }

    var value = source[Object.keys(source)[0]];
    return typeof value === "string";
  },
  isStructured: function isStructured(source) {
    if (!source) {
      return false;
    }

    var value = source[Object.keys(source)[0]];
    return value !== null && typeof value === "object" && !this.isFrame(source);
  }
};
var DittoContext = React.createContext({});

var filterBlock = function filterBlock(blockObj, variables, count, filters) {
  return Object.keys(blockObj).filter(function (textId) {
    if (!(filters != null && filters.tags)) return true;
    return filters.tags.every(function (tag) {
      return blockObj[textId].tags && blockObj[textId].tags.includes(tag);
    });
  }).reduce(function (obj, id) {
    var _extends2;

    var interpolatedText = interpolateVariableText(blockObj[id], variables, count).text;
    return _extends({}, obj, (_extends2 = {}, _extends2[id] = interpolatedText, _extends2));
  }, {});
};
var filterFrame = function filterFrame(_frameObj, variables, count, filters) {
  var frameObj = JSON.parse(JSON.stringify(_frameObj));

  if (frameObj.blocks) {
    for (var blockId in frameObj.blocks) {
      frameObj.blocks[blockId] = filterBlock(frameObj.blocks[blockId], variables, count, filters);
    }
  }

  return _extends({}, frameObj, {
    otherText: filterBlock(frameObj.otherText, variables, count, filters)
  });
};
var error = function error(message, returnValue) {
  if (returnValue === void 0) {
    returnValue = message;
  }

  console.error(message);
  return returnValue;
};
var nullError = function nullError(message) {
  return error(message, null);
};
var fragmentError = function fragmentError(message) {
  return error(message, jsxRuntime.jsx(React.Fragment, {}, void 0));
};
var isProject = function isProject(props, projectIdFromContext) {
  return ("projectId" in props || !!projectIdFromContext) && ("textId" in props || "frameId" in props || "blockId" in props);
};
var isComponentLibrary = function isComponentLibrary(props) {
  return "componentId" in props;
};
var isText = function isText(props) {
  return "textId" in props;
};
var isFrameOrBlockComponent = function isFrameOrBlockComponent(props) {
  return "frameId" in props;
};
var useProjectId = function useProjectId(props) {
  var dittoContext = React.useContext(DittoContext);
  var projectId = dittoContext.projectId || props.projectId;

  if (!projectId) {
    return fragmentError("No Project ID was provided to the <DittoProvider /> or <Ditto /> components.");
  }

  return projectId;
};
/**
 *
 * @param data
 * text data
 * @param count
 * the variable number used to determine which plural case to use
 * zero = 0
 * one = 1
 * two = 2
 * few = 3,4,5
 * many = 6,7,...,99
 * other = 100, 101, ...
 * if count is provided but not matching plural key, fallback to base plural value
 * in future we should also user's to define their own middleware for picking plurals
 * based off i8next: https://www.i18next.com/translation-function/plurals
 */

var getPluralText = function getPluralText(data, count) {
  var _Object$keys;

  if (count === undefined || ((_Object$keys = Object.keys((data == null ? void 0 : data.plurals) || {})) == null ? void 0 : _Object$keys.length) === 0) {
    return data.text;
  } else if (count === 0 && data.plurals.zero) {
    return data.plurals.zero;
  } else if (count === 1 && data.plurals.one) {
    return data.plurals.one;
  } else if (count === 2 && data.plurals.two) {
    return data.plurals.two;
  } else if (count >= 3 && count <= 5 && data.plurals.few) {
    return data.plurals.few;
  } else if (count >= 6 && count <= 99 && data.plurals.many) {
    return data.plurals.many;
  } else {
    // default to 'other', fallback to base text
    if (data.plurals.other) return data.plurals.other;
    return data.text;
  }
};

var interpolateVariableText = function interpolateVariableText(data, variables, count) {
  var variablesWithFallbacks = Object.keys((data == null ? void 0 : data.variables) || {}).reduce(function (acc, curr) {
    if (variables[curr]) {
      acc[curr] = variables[curr];
    } else {
      var _data$variables$curr = data.variables[curr],
          fallback = _data$variables$curr.fallback,
          text = _data$variables$curr.text;
      acc[curr] = fallback || text;
    }

    return acc;
  }, {});
  var pluralText = getPluralText(data, count);
  return _extends({}, data, {
    text: generateVariableText(pluralText, variablesWithFallbacks)
  });
};
var HANDLEBAR_REGEX = /\{\{([a-z0-9_]+)\}\}/gi;
/**
 * Execute a callback for each valid variable found in
 * `text`. The callback is passed an object that includes:
 * - `name`: the name of the variable
 * - `start`: the index of opening curly brace of the variable in `text`
 * - `end`: the index of the closing curly brace of the variable in `text`
 */

var forEachVariable = function forEachVariable(text, callback) {
  var matches = null;

  while ((matches = HANDLEBAR_REGEX.exec(text)) !== null) {
    var _matches = matches,
        match = _matches[0];

    if (!match) {
      break;
    }

    var variableName = match.replace(/(\{\{|\}\})/g, "");
    callback({
      name: variableName,
      start: matches.index,
      end: matches.index + match.length - 1
    });
  }
};

var getVariable = function getVariable(variableName, variables) {
  var variable = variables[variableName];

  if (!variable) {
    return null;
  }

  return variable;
};

var getVariablePlaceholder = function getVariablePlaceholder(variable) {
  if (!(variable && variable.data)) {
    return null;
  }

  if (variable.data.fallback) {
    return String(variable.data.fallback);
  }

  if (variable.data.text) {
    return String(variable.data.text);
  }

  return null;
};

var generateVariableText = function generateVariableText(text, variables) {
  var lastIndex = 0;
  var updatedText = "";
  forEachVariable(text, function (_ref) {
    var name = _ref.name,
        start = _ref.start,
        end = _ref.end;
    var variableValue = getVariable(name, variables) || getVariablePlaceholder(name);

    if (variableValue) {
      updatedText += text.substring(lastIndex, start) + variableValue;
    } else {
      updatedText += text.substr(lastIndex, end + 1);
    }

    lastIndex = end + 1;
  });
  var remainder = text.substr(lastIndex);

  if (remainder) {
    updatedText += remainder;
  }

  return updatedText;
};

var useDittoSingleText = function useDittoSingleText(props) {
  var _source$projectId2;

  var projectId = props.projectId,
      textId = props.textId,
      variables = props.variables,
      count = props.count;

  var _useContext = React.useContext(DittoContext),
      source = _useContext.source,
      variant = _useContext.variant;

  if (!projectId) return nullError("No Project ID provided.");

  if (variant) {
    var _source$projectId;

    var _data = source == null ? void 0 : (_source$projectId = source[projectId]) == null ? void 0 : _source$projectId[variant];

    if (_data) {
      if (SourceDetector.isStructured(_data)) {
        return interpolateVariableText(_data[textId], variables, count).text;
      }

      if (SourceDetector.isFlat(_data)) {
        return _data[textId];
      }

      if (SourceDetector.isFrame(_data)) {
        for (var frameId in _data) {
          var frame = _data[frameId];

          for (var blockId in frame.blocks) {
            var block = frame.blocks[blockId];
            if (textId in block) return interpolateVariableText(block[textId], variables, count).text;
          }

          if (frame.otherText && textId in frame.otherText) return interpolateVariableText(frame.otherText[textId], variables, count).text;
        }
      }
    }
  }

  var data = source == null ? void 0 : (_source$projectId2 = source[projectId]) == null ? void 0 : _source$projectId2.base;

  if (!data) {
    return nullError("Project not found with id \"" + projectId + "\"");
  }

  if (SourceDetector.isStructured(data)) {
    return interpolateVariableText(data[textId], variables, count).text;
  }

  if (SourceDetector.isFlat(data)) {
    return data[textId];
  }

  if (SourceDetector.isFrame(data)) {
    for (var _frameId in data) {
      var _frame = data[_frameId];

      for (var _blockId in _frame.blocks) {
        var _block = _frame.blocks[_blockId];
        if (textId in _block) return interpolateVariableText(_block[textId], variables, count).text;
      }

      if (_frame.otherText && textId in _frame.otherText) return interpolateVariableText(_frame.otherText[textId], variables, count).text;
    }
  }

  return "Text not found for id \"" + textId + "\"";
};

var DittoText = function DittoText(props) {
  var textId = props.textId,
      children = props.children,
      variables = props.variables,
      count = props.count;
  var projectId = useProjectId(props);
  var text = useDittoSingleText({
    projectId: projectId,
    textId: textId,
    variables: variables || {},
    count: count
  });
  return jsxRuntime.jsx(React__default['default'].Fragment, {
    children: typeof children === "function" ? children(text) : text
  }, void 0);
};

var useDitto = function useDitto(props) {
  var _source$projectId2;

  var projectId = props.projectId,
      frameId = props.frameId,
      blockId = props.blockId,
      filters = props.filters,
      variables = props.variables,
      count = props.count;

  var _useContext = React.useContext(DittoContext),
      source = _useContext.source,
      variant = _useContext.variant;

  if (!projectId) return nullError("No Project ID provided.");

  if (variant) {
    var _source$projectId;

    var _data = source == null ? void 0 : (_source$projectId = source[projectId]) == null ? void 0 : _source$projectId[variant];

    if (SourceDetector.isFrame(_data) && frameId) {
      var _frame = _data[frameId];

      if (_frame) {
        if (!blockId) {
          return filterFrame(_frame, variables || {}, count, filters);
        }

        if (blockId in _frame.blocks) {
          var _block = _frame.blocks[blockId];

          if (_block) {
            return filterBlock(_block, variables || {}, count, filters);
          }
        }
      }
    }
  }

  var data = (_source$projectId2 = source[projectId]) == null ? void 0 : _source$projectId2.base;

  if (!data) {
    return nullError("Project not found with id \"" + projectId + "\"");
  }

  if (!SourceDetector.isFrame(data)) {
    return nullError("Default format must be used if passing \"frameId\" or \"blockId\"");
  }

  if (!frameId) {
    return nullError("No Frame ID provided.");
  }

  var frame = data[frameId];
  if (!frame) return nullError("Frame \"" + frameId + "\" not found this project \"" + projectId + "\"");
  if (!blockId) return filterFrame(frame, variables || {}, count, filters);
  var block = frame.blocks[blockId];
  if (!block) return nullError("Block \"" + blockId + "\" not found in frame \"" + frameId + "\" in project \"" + projectId + "\"");
  return filterBlock(block, variables || {}, count, filters);
};

var _excluded = ["children"];
var DittoFrameOrBlock = function DittoFrameOrBlock(props) {
  var children = props.children,
      otherProps = _objectWithoutPropertiesLoose(props, _excluded);

  var data = useDitto(otherProps);

  if (typeof children !== "function") {
    return fragmentError("Please provide either a textId or function child to your Ditto component.");
  }

  if (!data || typeof data !== "object") {
    return jsxRuntime.jsx(jsxRuntime.Fragment, {
      children: data
    }, void 0);
  }

  return jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: children(data)
  }, void 0);
};
var DittoFrame = function DittoFrame(props) {
  var projectId = useProjectId(props);
  return jsxRuntime.jsx(DittoFrameOrBlock, Object.assign({}, props, {
    projectId: projectId
  }), void 0);
};
var DittoBlock = function DittoBlock(props) {
  var projectId = useProjectId(props);
  return jsxRuntime.jsx(DittoFrameOrBlock, Object.assign({}, props, {
    projectId: projectId
  }), void 0);
};

var useDittoComponent = function useDittoComponent(props) {
  var _source$ditto_compone2;

  var componentId = props.componentId,
      alwaysReturnString = props.alwaysReturnString,
      variables = props.variables,
      count = props.count;

  var _useContext = React.useContext(DittoContext),
      source = _useContext.source,
      variant = _useContext.variant;

  if (!("ditto_component_library" in source)) {
    throw new Error("An export file for the Component Library couldn't be found.");
  }

  if (variant) {
    var _source$ditto_compone;

    var _data = source == null ? void 0 : (_source$ditto_compone = source.ditto_component_library) == null ? void 0 : _source$ditto_compone[variant];

    if (_data && _data[componentId]) {
      if (SourceDetector.isStructured(_data)) {
        var value = interpolateVariableText(_data[componentId], variables, count);
        return alwaysReturnString ? value.text : value;
      } else if (SourceDetector.isFlat(_data)) {
        return _data[componentId];
      }
    }
  }

  var data = source == null ? void 0 : (_source$ditto_compone2 = source.ditto_component_library) == null ? void 0 : _source$ditto_compone2.base;

  if (!data) {
    return nullError("Base text not found in component library");
  }

  if (data && !data[componentId]) {
    return nullError("Text not found for component \"" + componentId + "\"");
  }

  if (SourceDetector.isStructured(data)) {
    var _value = interpolateVariableText(data[componentId], variables, count);

    return alwaysReturnString ? _value.text : _value;
  } else if (SourceDetector.isFlat(data)) {
    return data[componentId];
  } else {
    return nullError("Invalid format for component " + componentId);
  }
};

var DittoComponent = function DittoComponent(props) {
  var children = props.children,
      componentId = props.componentId,
      variables = props.variables,
      count = props.count;
  var value = useDittoComponent({
    componentId: componentId,
    alwaysReturnString: typeof children !== "function",
    variables: variables || {},
    count: count
  });
  var text = React.useMemo(function () {
    return value !== null && typeof value === "object" ? value.text : value;
  }, [value]);
  return jsxRuntime.jsx(React__default['default'].Fragment, {
    children: typeof children === "function" ? children(text) : text
  }, void 0);
};

function Ditto(props) {
  var dittoContext = React.useContext(DittoContext);

  if (isComponentLibrary(props)) {
    return jsxRuntime.jsx(DittoComponent, Object.assign({}, props), void 0);
  }

  if (isProject(props, dittoContext.projectId)) {
    var projectId = props.projectId || dittoContext.projectId;

    if (!projectId) {
      return fragmentError("No Project ID was provided to the <DittoProvider /> or <Ditto /> components.");
    }

    var propsWithProject = _extends({}, props, {
      projectId: projectId
    });

    if (isText(propsWithProject)) {
      return jsxRuntime.jsx(DittoText, Object.assign({}, propsWithProject), void 0);
    }

    if (isFrameOrBlockComponent(propsWithProject)) {
      return jsxRuntime.jsx(DittoFrameOrBlock, Object.assign({}, propsWithProject), void 0);
    }
  }

  return fragmentError('Invalid props provided to Ditto component; please provide "componentId", "textId" or "frameId"');
}

var DittoProvider = function DittoProvider(props) {
  var children = props.children,
      source = props.source,
      variant = props.variant,
      projectId = props.projectId;
  return jsxRuntime.jsx(DittoContext.Provider, Object.assign({
    value: _extends({
      source: source,
      variant: variant
    }, projectId ? {
      projectId: projectId
    } : {})
  }, {
    children: children
  }), void 0);
};

exports.Ditto = Ditto;
exports.DittoBlock = DittoBlock;
exports.DittoComponent = DittoComponent;
exports.DittoFrame = DittoFrame;
exports.DittoProvider = DittoProvider;
exports.DittoText = DittoText;
exports.default = DittoProvider;
//# sourceMappingURL=index.js.map
